<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>NIO网络通信 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Docs Oracle官方文档:https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;8&#x2F;docs&#x2F;api&#x2F;java&#x2F;nio&#x2F;package-summary.html Practice Repository:https:&#x2F;&#x2F;github.com&#x2F;bakazhou&#x2F;JUC  NIO(非阻塞IO)基础1.三大组件1.1 Channel &amp; Bufferchannel与buffer是双向">
<meta property="og:type" content="article">
<meta property="og:title" content="NIO网络通信">
<meta property="og:url" content="http://example.com/2022/09/23/NIO%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Docs Oracle官方文档:https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;8&#x2F;docs&#x2F;api&#x2F;java&#x2F;nio&#x2F;package-summary.html Practice Repository:https:&#x2F;&#x2F;github.com&#x2F;bakazhou&#x2F;JUC  NIO(非阻塞IO)基础1.三大组件1.1 Channel &amp; Bufferchannel与buffer是双向">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c2fd018da4f4b11a3e497562afa00d9~tplv-k3u1fbpfcp-watermark.image">
<meta property="og:image" content="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c620117b0c24dd4a97a7df9ff4a1db1~tplv-k3u1fbpfcp-watermark.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/935fa244f6e748759a060eee21bb5ba1~tplv-k3u1fbpfcp-watermark.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d44da2501bb2445ea3c6ea69cf4dca59~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e027706f70e4c2aa3ee1419f1411f01~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ff0f0e912474961bfc179987b546568~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e99870102d89422f830d84560bc4ad81~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e999bcbd7f24a329e05798e979927bc~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b02b7fd679764720aff715da78881ac8~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70ae74562fbb4b318eb52f510b0b801b~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5179898ec9c64325a74e0a72e1681da2~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c022c78f4174fcaaba370ce0e105648~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fbcfe71a0a484b39a88cef503b439d46~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c772b7242c54afba56f1568f5505a08~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/270cdcfcad3e4c49b9ca894b3b4092fe~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f783ddb84b94a5591e0786fb8d83b4d~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a9d5b85a8c10475d8fe9cbfb1822c44e~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/57a5e9aeb2bb46b781b4e81b11c431a0~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dbf572cef10749c9b36859d3b7c5eeee~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2ada3cf2710433dbebf60630666fa8e~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="article:published_time" content="2022-09-23T06:47:49.000Z">
<meta property="article:modified_time" content="2022-09-23T06:48:32.598Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c2fd018da4f4b11a3e497562afa00d9~tplv-k3u1fbpfcp-watermark.image">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-NIO网络通信" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/09/23/NIO%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/" class="article-date">
  <time class="dt-published" datetime="2022-09-23T06:47:49.000Z" itemprop="datePublished">2022-09-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      NIO网络通信
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Docs"><a href="#Docs" class="headerlink" title="Docs"></a>Docs</h1><ul>
<li>Oracle官方文档:<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/nio/package-summary.html">https://docs.oracle.com/javase/8/docs/api/java/nio/package-summary.html</a></li>
<li>Practice Repository:<a target="_blank" rel="noopener" href="https://github.com/bakazhou/JUC">https://github.com/bakazhou/JUC</a></li>
</ul>
<h1 id="NIO-非阻塞IO-基础"><a href="#NIO-非阻塞IO-基础" class="headerlink" title="NIO(非阻塞IO)基础"></a>NIO(非阻塞IO)基础</h1><h2 id="1-三大组件"><a href="#1-三大组件" class="headerlink" title="1.三大组件"></a>1.三大组件</h2><h3 id="1-1-Channel-amp-Buffer"><a href="#1-1-Channel-amp-Buffer" class="headerlink" title="1.1 Channel &amp; Buffer"></a>1.1 Channel &amp; Buffer</h3><p>channel与buffer是<code>双向通道</code>，可以从channel将数据读入buffer，也可以将buffer数据写入channel<br>常见的channel:</p>
<ul>
<li>File Channel</li>
<li>Datagram Channel</li>
<li>Socket Channel</li>
<li>Server Socket Channel</li>
</ul>
<p>常用的buffer:</p>
<ul>
<li>ByteBuffer(以下三种均属于ByteBuffer)</li>
<li>MapperByteBuffer</li>
<li>DirectByteBuffer</li>
<li>HeapByteBuffer</li>
</ul>
<h3 id="1-2-Selector"><a href="#1-2-Selector" class="headerlink" title="1.2 Selector"></a>1.2 Selector</h3><h4 id="传统通信设计"><a href="#传统通信设计" class="headerlink" title="传统通信设计"></a>传统通信设计</h4><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c2fd018da4f4b11a3e497562afa00d9~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c620117b0c24dd4a97a7df9ff4a1db1~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h4 id="Selector设计"><a href="#Selector设计" class="headerlink" title="Selector设计"></a>Selector设计</h4><p>selector的作用是配合一个线程管理多个channel，获取channel上发生的事件，channel工作在非阻塞模式下，当channel发生了读写就绪事件，selector会将事件交给thread进行处理</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/935fa244f6e748759a060eee21bb5ba1~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h2 id="2-ByteBuffer"><a href="#2-ByteBuffer" class="headerlink" title="2.ByteBuffer"></a>2.ByteBuffer</h2><h3 id="2-1-ByteBuffer基本使用"><a href="#2-1-ByteBuffer基本使用" class="headerlink" title="2.1 ByteBuffer基本使用"></a>2.1 ByteBuffer基本使用</h3><p>有一普通文本文件data.txt，内容为如下，读取其中数据并组成字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1234567890abcd</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">void shouldReturnStringWhenReadData() &#123;</span><br><span class="line">    //File Channel</span><br><span class="line">    //通过输入输出流</span><br><span class="line">    try(FileChannel channel = new FileInputStream(&quot;src/data.txt&quot;).getChannel()) &#123;</span><br><span class="line">        //准备缓冲区</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(1);</span><br><span class="line"></span><br><span class="line">        StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //从Channel读取，向Buffer写入</span><br><span class="line">        while (channel.read(buffer) != -1)&#123;</span><br><span class="line">            //切换到buffer的读模式</span><br><span class="line">            buffer.flip();</span><br><span class="line">            while (buffer.hasRemaining())&#123;</span><br><span class="line">                byte b = buffer.get();</span><br><span class="line">                stringBuilder.append((char) b);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //切换到写模式</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Assertions.assertEquals(&quot;1234567890abcd&quot;,stringBuilder.toString());</span><br><span class="line"></span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        throw new RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-Buffer结构"><a href="#2-2-Buffer结构" class="headerlink" title="2.2 Buffer结构"></a>2.2 Buffer结构</h3><p>字节缓冲区的父类Buffer中有几个核心属性，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Invariants: mark &lt;= position &lt;= limit &lt;= capacity</span><br><span class="line">private int mark = -1;</span><br><span class="line">private int position = 0;</span><br><span class="line">private int limit;</span><br><span class="line">private int capacity;Copy</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>capacity</strong>：缓冲区的容量。通过构造函数赋予，一旦设置，无法更改</li>
<li><strong>limit</strong>：缓冲区的界限。位于limit 后的数据不可读写。缓冲区的限制不能为负，并且<strong>不能大于其容量</strong></li>
<li><strong>position</strong>：<strong>下一个</strong>读写位置的索引（类似PC）。缓冲区的位置不能为负，并且<strong>不能大于limit</strong></li>
<li><strong>mark</strong>：记录当前position的值。<strong>position被改变后，可以通过调用reset() 方法恢复到mark的位置。</strong></li>
</ul>
<p>以上四个属性必须满足以下要求<br><strong>mark &lt;&#x3D; position &lt;&#x3D; limit &lt;&#x3D; capacity</strong></p>
<h3 id="2-3-核心方法"><a href="#2-3-核心方法" class="headerlink" title="2.3 核心方法"></a>2.3 核心方法</h3><h4 id="put-方法"><a href="#put-方法" class="headerlink" title="put()方法"></a>put()方法<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#put-%E6%96%B9%E6%B3%95"></a></h4><ul>
<li>put()方法可以将一个数据放入到缓冲区中。</li>
<li>进行该操作后，postition的值会+1，指向下一个可以放入的位置。capacity &#x3D; limit ，为缓冲区容量的值。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26a1a6ee0e304eeaa3886e0309cc7f53~tplv-k3u1fbpfcp-zoom-1.image"></a><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145709.png"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d44da2501bb2445ea3c6ea69cf4dca59~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></a></p>
<h4 id="flip-方法"><a href="#flip-方法" class="headerlink" title="flip()方法"></a><a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#flip-%E6%96%B9%E6%B3%95" title="flip()方法"></a>flip()方法<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#flip-%E6%96%B9%E6%B3%95"></a></h4><ul>
<li><p>flip()方法会<strong>切换对缓冲区的操作模式</strong>，由写-&gt;读 &#x2F; 读-&gt;写</p>
</li>
<li><p>进行该操作后</p>
<ul>
<li>如果是写模式-&gt;读模式，position &#x3D; 0 ， limit 指向最后一个元素的下一个位置，capacity不变</li>
<li>如果是读-&gt;写，则恢复为put()方法中的值</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8049578775f419e9127e6d4e0173109~tplv-k3u1fbpfcp-zoom-1.image"></a><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145753.png"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e027706f70e4c2aa3ee1419f1411f01~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></a></p>
<h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a><a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#get-%E6%96%B9%E6%B3%95" title="get()方法"></a>get()方法<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#get-%E6%96%B9%E6%B3%95"></a></h4><ul>
<li>get()方法会读取缓冲区中的一个值</li>
<li>进行该操作后，position会+1，如果超过了limit则会抛出异常</li>
<li><strong>注意：get(i)方法不会改变position的值</strong></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f4efa4e4865442ab9bd39c152742705~tplv-k3u1fbpfcp-zoom-1.image"></a><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145822.png"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ff0f0e912474961bfc179987b546568~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></a></p>
<h4 id="rewind-方法"><a href="#rewind-方法" class="headerlink" title="rewind()方法"></a><a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#rewind-%E6%96%B9%E6%B3%95" title="rewind()方法"></a>rewind()方法<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#rewind-%E6%96%B9%E6%B3%95"></a></h4><ul>
<li>该方法<strong>只能在读模式下使用</strong></li>
<li>rewind()方法后，会恢复position、limit和capacity的值，变为进行get()前的值</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72072c84f6c2400cbea81eeddec126d3~tplv-k3u1fbpfcp-zoom-1.image"></a><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145852.png"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e99870102d89422f830d84560bc4ad81~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></a></p>
<h4 id="clean-方法"><a href="#clean-方法" class="headerlink" title="clean()方法"></a><a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#clean-%E6%96%B9%E6%B3%95" title="clean()方法"></a>clean()方法<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#clean-%E6%96%B9%E6%B3%95"></a></h4><ul>
<li>clean()方法会将缓冲区中的各个属性恢复为最初的状态，position &#x3D; 0, capacity &#x3D; limit</li>
<li><strong>此时缓冲区的数据依然存在</strong>，处于“被遗忘”状态，下次进行写操作时会覆盖这些数据</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b680896cf3744f8b52f041e5522039a~tplv-k3u1fbpfcp-zoom-1.image"></a><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145905.png"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e999bcbd7f24a329e05798e979927bc~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></a></p>
<h4 id="mark-和reset-方法"><a href="#mark-和reset-方法" class="headerlink" title="mark()和reset()方法"></a><a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#mark-%E5%92%8Creset-%E6%96%B9%E6%B3%95" title="mark()和reset()方法"></a>mark()和reset()方法<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#mark-%E5%92%8Creset-%E6%96%B9%E6%B3%95"></a></h4><ul>
<li>mark()方法会将postion的值保存到mark属性中</li>
<li>reset()方法会将position的值改为mark中保存的值</li>
</ul>
<h4 id="compact-方法"><a href="#compact-方法" class="headerlink" title="compact()方法"></a><a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#compact-%E6%96%B9%E6%B3%95" title="compact()方法"></a>compact()方法<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#compact-%E6%96%B9%E6%B3%95"></a></h4><p><strong>此方法为ByteBuffer的方法，而不是Buffer的方法</strong></p>
<ul>
<li>compact会把未读完的数据向前压缩，然后切换到写模式</li>
<li>数据前移后，原位置的值并未清零，写时会<strong>覆盖</strong>之前的值</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210412155726.png"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b02b7fd679764720aff715da78881ac8~tplv-k3u1fbpfcp-zoom-1.image"></a></p>
<h4 id="clear-VS-compact"><a href="#clear-VS-compact" class="headerlink" title="clear() VS compact()"></a><a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#clear-VS-compact" title="clear() VS compact()"></a>clear() VS compact()<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#clear-VS-compact"></a></h4><p>clear只是对position、limit、mark进行重置，而compact在对position进行设置，以及limit、mark进行重置的同时，还涉及到数据在内存中拷贝（会调用arraycopy）。<strong>所以compact比clear更耗性能。</strong> 但compact能保存你未读取的数据，将新数据追加到为读取的数据之后；而clear则不行，若你调用了clear，则未读取的数据就无法再读取到了</p>
<h4 id="开辟buffer空间的两种方式-allocate-amp-allocateDirect"><a href="#开辟buffer空间的两种方式-allocate-amp-allocateDirect" class="headerlink" title="开辟buffer空间的两种方式(allocate &amp; allocateDirect)"></a><strong>开辟buffer空间的两种方式(allocate &amp; allocateDirect)</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//allocate方法开辟的是堆内存空间，读写效率低，同时收到垃圾回收的影响</span><br><span class="line">ByteBuffer allocate = ByteBuffer.allocate(16);</span><br><span class="line">//allocateDirect方法开辟的是直接内存，读写效率高，分配效率低，可能会造成内存泄漏</span><br><span class="line">ByteBuffer byteBuffer = ByteBuffer.allocateDirect(16);</span><br></pre></td></tr></table></figure>

<h3 id="2-4-核心方法测试"><a href="#2-4-核心方法测试" class="headerlink" title="2.4 核心方法测试"></a>2.4 核心方法测试</h3><h4 id="工具类-ByteBufferUtil"><a href="#工具类-ByteBufferUtil" class="headerlink" title="工具类 ByteBufferUtil"></a>工具类 ByteBufferUtil</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line">public class ByteBufferUtil &#123;</span><br><span class="line">    private static final char[] BYTE2CHAR = new char[256];</span><br><span class="line">    private static final char[] HEXDUMP_TABLE = new char[256 * 4];</span><br><span class="line">    private static final String[] HEXPADDING = new String[16];</span><br><span class="line">    private static final String[] HEXDUMP_ROWPREFIXES = new String[65536 &gt;&gt;&gt; 4];</span><br><span class="line">    private static final String[] BYTE2HEX = new String[256];</span><br><span class="line">    private static final String[] BYTEPADDING = new String[16];</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        final char[] DIGITS = &quot;0123456789abcdef&quot;.toCharArray();</span><br><span class="line">        for (int i = 0; i &lt; 256; i++) &#123;</span><br><span class="line">            HEXDUMP_TABLE[i &lt;&lt; 1] = DIGITS[i &gt;&gt;&gt; 4 &amp; 0x0F];</span><br><span class="line">            HEXDUMP_TABLE[(i &lt;&lt; 1) + 1] = DIGITS[i &amp; 0x0F];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int i;</span><br><span class="line"></span><br><span class="line">        // Generate the lookup table for hex dump paddings</span><br><span class="line">        for (i = 0; i &lt; HEXPADDING.length; i++) &#123;</span><br><span class="line">            int padding = HEXPADDING.length - i;</span><br><span class="line">            StringBuilder buf = new StringBuilder(padding * 3);</span><br><span class="line">            for (int j = 0; j &lt; padding; j++) &#123;</span><br><span class="line">                buf.append(&quot;   &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            HEXPADDING[i] = buf.toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Generate the lookup table for the start-offset header in each row (up to 64KiB).</span><br><span class="line">        for (i = 0; i &lt; HEXDUMP_ROWPREFIXES.length; i++) &#123;</span><br><span class="line">            StringBuilder buf = new StringBuilder(12);</span><br><span class="line">            buf.append(StringUtil.NEWLINE);</span><br><span class="line">            buf.append(Long.toHexString(i &lt;&lt; 4 &amp; 0xFFFFFFFFL | 0x100000000L));</span><br><span class="line">            buf.setCharAt(buf.length() - 9, &#x27;|&#x27;);</span><br><span class="line">            buf.append(&#x27;|&#x27;);</span><br><span class="line">            HEXDUMP_ROWPREFIXES[i] = buf.toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Generate the lookup table for byte-to-hex-dump conversion</span><br><span class="line">        for (i = 0; i &lt; BYTE2HEX.length; i++) &#123;</span><br><span class="line">            BYTE2HEX[i] = &#x27; &#x27; + StringUtil.byteToHexStringPadded(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Generate the lookup table for byte dump paddings</span><br><span class="line">        for (i = 0; i &lt; BYTEPADDING.length; i++) &#123;</span><br><span class="line">            int padding = BYTEPADDING.length - i;</span><br><span class="line">            StringBuilder buf = new StringBuilder(padding);</span><br><span class="line">            for (int j = 0; j &lt; padding; j++) &#123;</span><br><span class="line">                buf.append(&#x27; &#x27;);</span><br><span class="line">            &#125;</span><br><span class="line">            BYTEPADDING[i] = buf.toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Generate the lookup table for byte-to-char conversion</span><br><span class="line">        for (i = 0; i &lt; BYTE2CHAR.length; i++) &#123;</span><br><span class="line">            if (i &lt;= 0x1f || i &gt;= 0x7f) &#123;</span><br><span class="line">                BYTE2CHAR[i] = &#x27;.&#x27;;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                BYTE2CHAR[i] = (char) i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 打印所有内容</span><br><span class="line">     * @param buffer</span><br><span class="line">     */</span><br><span class="line">    public static void debugAll(ByteBuffer buffer) &#123;</span><br><span class="line">        int oldlimit = buffer.limit();</span><br><span class="line">        buffer.limit(buffer.capacity());</span><br><span class="line">        StringBuilder origin = new StringBuilder(256);</span><br><span class="line">        appendPrettyHexDump(origin, buffer, 0, buffer.capacity());</span><br><span class="line">        System.out.println(&quot;+--------+-------------------- all ------------------------+----------------+&quot;);</span><br><span class="line">        System.out.printf(&quot;position: [%d], limit: [%d]\n&quot;, buffer.position(), oldlimit);</span><br><span class="line">        System.out.println(origin);</span><br><span class="line">        buffer.limit(oldlimit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 打印可读取内容</span><br><span class="line">     * @param buffer</span><br><span class="line">     */</span><br><span class="line">    public static void debugRead(ByteBuffer buffer) &#123;</span><br><span class="line">        StringBuilder builder = new StringBuilder(256);</span><br><span class="line">        appendPrettyHexDump(builder, buffer, buffer.position(), buffer.limit() - buffer.position());</span><br><span class="line">        System.out.println(&quot;+--------+-------------------- read -----------------------+----------------+&quot;);</span><br><span class="line">        System.out.printf(&quot;position: [%d], limit: [%d]\n&quot;, buffer.position(), buffer.limit());</span><br><span class="line">        System.out.println(builder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void appendPrettyHexDump(StringBuilder dump, ByteBuffer buf, int offset, int length) &#123;</span><br><span class="line">        if (MathUtil.isOutOfBounds(offset, length, buf.capacity())) &#123;</span><br><span class="line">            throw new IndexOutOfBoundsException(</span><br><span class="line">                    &quot;expected: &quot; + &quot;0 &lt;= offset(&quot; + offset + &quot;) &lt;= offset + length(&quot; + length</span><br><span class="line">                            + &quot;) &lt;= &quot; + &quot;buf.capacity(&quot; + buf.capacity() + &#x27;)&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (length == 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        dump.append(</span><br><span class="line">                &quot;         +-------------------------------------------------+&quot; +</span><br><span class="line">                        StringUtil.NEWLINE + &quot;         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |&quot; +</span><br><span class="line">                        StringUtil.NEWLINE + &quot;+--------+-------------------------------------------------+----------------+&quot;);</span><br><span class="line"></span><br><span class="line">        final int startIndex = offset;</span><br><span class="line">        final int fullRows = length &gt;&gt;&gt; 4;</span><br><span class="line">        final int remainder = length &amp; 0xF;</span><br><span class="line"></span><br><span class="line">        // Dump the rows which have 16 bytes.</span><br><span class="line">        for (int row = 0; row &lt; fullRows; row++) &#123;</span><br><span class="line">            int rowStartIndex = (row &lt;&lt; 4) + startIndex;</span><br><span class="line"></span><br><span class="line">            // Per-row prefix.</span><br><span class="line">            appendHexDumpRowPrefix(dump, row, rowStartIndex);</span><br><span class="line"></span><br><span class="line">            // Hex dump</span><br><span class="line">            int rowEndIndex = rowStartIndex + 16;</span><br><span class="line">            for (int j = rowStartIndex; j &lt; rowEndIndex; j++) &#123;</span><br><span class="line">                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);</span><br><span class="line">            &#125;</span><br><span class="line">            dump.append(&quot; |&quot;);</span><br><span class="line"></span><br><span class="line">            // ASCII dump</span><br><span class="line">            for (int j = rowStartIndex; j &lt; rowEndIndex; j++) &#123;</span><br><span class="line">                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);</span><br><span class="line">            &#125;</span><br><span class="line">            dump.append(&#x27;|&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Dump the last row which has less than 16 bytes.</span><br><span class="line">        if (remainder != 0) &#123;</span><br><span class="line">            int rowStartIndex = (fullRows &lt;&lt; 4) + startIndex;</span><br><span class="line">            appendHexDumpRowPrefix(dump, fullRows, rowStartIndex);</span><br><span class="line"></span><br><span class="line">            // Hex dump</span><br><span class="line">            int rowEndIndex = rowStartIndex + remainder;</span><br><span class="line">            for (int j = rowStartIndex; j &lt; rowEndIndex; j++) &#123;</span><br><span class="line">                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);</span><br><span class="line">            &#125;</span><br><span class="line">            dump.append(HEXPADDING[remainder]);</span><br><span class="line">            dump.append(&quot; |&quot;);</span><br><span class="line"></span><br><span class="line">            // Ascii dump</span><br><span class="line">            for (int j = rowStartIndex; j &lt; rowEndIndex; j++) &#123;</span><br><span class="line">                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);</span><br><span class="line">            &#125;</span><br><span class="line">            dump.append(BYTEPADDING[remainder]);</span><br><span class="line">            dump.append(&#x27;|&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dump.append(StringUtil.NEWLINE +</span><br><span class="line">                &quot;+--------+-------------------------------------------------+----------------+&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void appendHexDumpRowPrefix(StringBuilder dump, int row, int rowStartIndex) &#123;</span><br><span class="line">        if (row &lt; HEXDUMP_ROWPREFIXES.length) &#123;</span><br><span class="line">            dump.append(HEXDUMP_ROWPREFIXES[row]);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            dump.append(StringUtil.NEWLINE);</span><br><span class="line">            dump.append(Long.toHexString(rowStartIndex &amp; 0xFFFFFFFFL | 0x100000000L));</span><br><span class="line">            dump.setCharAt(dump.length() - 9, &#x27;|&#x27;);</span><br><span class="line">            dump.append(&#x27;|&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static short getUnsignedByte(ByteBuffer buffer, int index) &#123;</span><br><span class="line">        return (short) (buffer.get(index) &amp; 0xFF);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="TestBufferReadWrite"><a href="#TestBufferReadWrite" class="headerlink" title="TestBufferReadWrite"></a>TestBufferReadWrite</h4><p>用于观察数据写入和读取后的缓冲区状态</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class TestBufferReadWrite &#123;</span><br><span class="line">    @Test</span><br><span class="line">    void test() &#123;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(10);</span><br><span class="line">        // 向buffer中写入1个字节的数据</span><br><span class="line">        buffer.put((byte)97);</span><br><span class="line">        // 使用工具类，查看buffer状态</span><br><span class="line">        System.out.println(&quot;Put one element&quot;);</span><br><span class="line">        ByteBufferUtil.debugAll(buffer);</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        // 向buffer中写入4个字节的数据</span><br><span class="line">        buffer.put(new byte[]&#123;98, 99, 100, 101&#125;);</span><br><span class="line">        System.out.println(&quot;Put four element&quot;);</span><br><span class="line">        ByteBufferUtil.debugAll(buffer);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        // 获取数据</span><br><span class="line">        buffer.flip();</span><br><span class="line">        System.out.println(&quot;before get&quot;);</span><br><span class="line">        ByteBufferUtil.debugAll(buffer);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        System.out.println(buffer.get());</span><br><span class="line">        System.out.println(buffer.get());</span><br><span class="line">        System.out.println(&quot;after get twice&quot;);</span><br><span class="line">        ByteBufferUtil.debugAll(buffer);</span><br><span class="line">        System.out.println();</span><br><span class="line">        // 使用compact切换模式</span><br><span class="line">        buffer.compact();</span><br><span class="line">        System.out.println(&quot;after compact&quot;);</span><br><span class="line">        ByteBufferUtil.debugAll(buffer);</span><br><span class="line">        System.out.println();</span><br><span class="line">        // 再次写入</span><br><span class="line">        buffer.put((byte)102);</span><br><span class="line">        buffer.put((byte)103);</span><br><span class="line">        System.out.println(&quot;after put double element again&quot;);</span><br><span class="line">        ByteBufferUtil.debugAll(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符串与ByteBuffer的相互转换"><a href="#字符串与ByteBuffer的相互转换" class="headerlink" title="字符串与ByteBuffer的相互转换"></a><strong>字符串与ByteBuffer的相互转换</strong><a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8EByteBuffer%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2"></a></h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a><a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#%E6%96%B9%E6%B3%95%E4%B8%80" title="方法一"></a>方法一<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#%E6%96%B9%E6%B3%95%E4%B8%80"></a></h4><p><strong>编码</strong>：字符串调用getByte方法获得byte数组，将byte数组放入ByteBuffer中</p>
<p><strong>解码</strong>：<strong>先调用ByteBuffer的flip方法，然后通过StandardCharsets的decoder方法解码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class TestTranslateString &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 准备两个字符串</span><br><span class="line">        String str1 = &quot;hello&quot;;</span><br><span class="line">        String str2 = &quot;&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ByteBuffer buffer1 = ByteBuffer.allocate(16);</span><br><span class="line">        // 通过字符串的getByte方法获得字节数组，放入缓冲区中</span><br><span class="line">        buffer1.put(str1.getBytes());</span><br><span class="line">        ByteBufferUtil.debugAll(buffer1);</span><br><span class="line"></span><br><span class="line">        // 将缓冲区中的数据转化为字符串</span><br><span class="line">        // 切换模式</span><br><span class="line">        buffer1.flip();</span><br><span class="line">        </span><br><span class="line">        // 通过StandardCharsets解码，获得CharBuffer，再通过toString获得字符串</span><br><span class="line">        str2 = StandardCharsets.UTF_8.decode(buffer1).toString();</span><br><span class="line">        System.out.println(str2);</span><br><span class="line">        ByteBufferUtil.debugAll(buffer1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+--------+-------------------- all ------------------------+----------------+</span><br><span class="line">position: [5], limit: [16]</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 68 65 6c 6c 6f 00 00 00 00 00 00 00 00 00 00 00 |hello...........|</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">hello</span><br><span class="line">+--------+-------------------- all ------------------------+----------------+</span><br><span class="line">position: [5], limit: [5]</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 68 65 6c 6c 6f 00 00 00 00 00 00 00 00 00 00 00 |hello...........|</span><br><span class="line">+--------+-------------------------------------------------+----------------+Copy</span><br></pre></td></tr></table></figure>

<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a><a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#%E6%96%B9%E6%B3%95%E4%BA%8C" title="方法二"></a>方法二<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#%E6%96%B9%E6%B3%95%E4%BA%8C"></a></h4><p><strong>编码</strong>：通过StandardCharsets的encode方法获得ByteBuffer，此时获得的ByteBuffer为读模式，无需通过flip切换模式</p>
<p><strong>解码</strong>：通过StandardCharsets的decoder方法解码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class TestTranslateString &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 准备两个字符串</span><br><span class="line">        String str1 = &quot;hello&quot;;</span><br><span class="line">        String str2 = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">        // 通过StandardCharsets的encode方法获得ByteBuffer</span><br><span class="line">        // 此时获得的ByteBuffer为读模式，无需通过flip切换模式</span><br><span class="line">        ByteBuffer buffer1 = StandardCharsets.UTF_8.encode(str1);</span><br><span class="line">        ByteBufferUtil.debugAll(buffer1);</span><br><span class="line"></span><br><span class="line">        // 将缓冲区中的数据转化为字符串</span><br><span class="line">        // 通过StandardCharsets解码，获得CharBuffer，再通过toString获得字符串</span><br><span class="line">        str2 = StandardCharsets.UTF_8.decode(buffer1).toString();</span><br><span class="line">        System.out.println(str2);</span><br><span class="line">        ByteBufferUtil.debugAll(buffer1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+--------+-------------------- all ------------------------+----------------+</span><br><span class="line">position: [0], limit: [5]</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 68 65 6c 6c 6f                                  |hello           |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">hello</span><br><span class="line">+--------+-------------------- all ------------------------+----------------+</span><br><span class="line">position: [5], limit: [5]</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 68 65 6c 6c 6f                                  |hello           |</span><br><span class="line">+--------+-------------------------------------------------+----------------+Copy</span><br></pre></td></tr></table></figure>

<h4 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a><a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#%E6%96%B9%E6%B3%95%E4%B8%89" title="方法三"></a><strong>方法三</strong><a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#%E6%96%B9%E6%B3%95%E4%B8%89"></a></h4><p><strong>编码</strong>：字符串调用getByte()方法获得字节数组，将字节数组传给<strong>ByteBuffer的wrap()方法</strong>，通过该方法获得ByteBuffer。<strong>同样无需调用flip方法切换为读模式</strong></p>
<p><strong>解码</strong>：通过StandardCharsets的decoder方法解码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class TestTranslateString &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 准备两个字符串</span><br><span class="line">        String str1 = &quot;hello&quot;;</span><br><span class="line">        String str2 = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">        // 通过StandardCharsets的encode方法获得ByteBuffer</span><br><span class="line">        // 此时获得的ByteBuffer为读模式，无需通过flip切换模式</span><br><span class="line">        ByteBuffer buffer1 = ByteBuffer.wrap(str1.getBytes());</span><br><span class="line">        ByteBufferUtil.debugAll(buffer1);</span><br><span class="line"></span><br><span class="line">        // 将缓冲区中的数据转化为字符串</span><br><span class="line">        // 通过StandardCharsets解码，获得CharBuffer，再通过toString获得字符串</span><br><span class="line">        str2 = StandardCharsets.UTF_8.decode(buffer1).toString();</span><br><span class="line">        System.out.println(str2);</span><br><span class="line">        ByteBufferUtil.debugAll(buffer1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+--------+-------------------- all ------------------------+----------------+</span><br><span class="line">position: [0], limit: [5]</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 68 65 6c 6c 6f                                  |hello           |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">hello</span><br><span class="line">+--------+-------------------- all ------------------------+----------------+</span><br><span class="line">position: [5], limit: [5]</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 68 65 6c 6c 6f                                  |hello           |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>

<h3 id="粘包与半包"><a href="#粘包与半包" class="headerlink" title="粘包与半包"></a>粘包与半包</h3><h4 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#%E7%8E%B0%E8%B1%A1"></a></h4><p>网络上有多条数据发送给服务端，数据之间使用\n进行分隔<br>但由于某种原因这些数据在接收时，被进行了重新组合，例如原始数据有3条为</p>
<ul>
<li>Hello,world\n</li>
<li>I’m Nyima\n</li>
<li>How are you?\n</li>
</ul>
<p>变成了下面的两个 byteBuffer (粘包，半包)</p>
<ul>
<li>Hello,world\nI’m Nyima\nHo</li>
<li>w are you?\n</li>
</ul>
<p><strong>粘包:</strong><br>两条消息被组合在一起即为粘包，一般出现的原因是因为多条消息被一起发送<br><strong>半包:</strong><br>消息被截断为半包，一般出现原因是因为接收方一次能接收的最大信息量有限，因而产生半包的现象</p>
<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"></a></h4><ul>
<li><p>通过get(index)方法遍历ByteBuffer，遇到分隔符时进行处理。<strong>注意</strong>：get(index)不会改变position的值</p>
<ul>
<li>记录该段数据长度，以便于申请对应大小的缓冲区</li>
<li>将缓冲区的数据通过get()方法写入到target中</li>
</ul>
</li>
<li><p>调用<strong>compact方法</strong>切换模式，因为缓冲区中可能还有未读的数据</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class TestVisioPacket &#123;</span><br><span class="line">    @Test</span><br><span class="line">    void testVisioPacket() &#123;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(32);</span><br><span class="line">        // 模拟粘包+半包</span><br><span class="line">        buffer.put(&quot;Hello,world\nI&#x27;m Nyima\nHo&quot;.getBytes());</span><br><span class="line">        // 调用split函数处理</span><br><span class="line">        split(buffer);</span><br><span class="line">        buffer.put(&quot;w are you?\n&quot;.getBytes());</span><br><span class="line">        split(buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void split(ByteBuffer buffer) &#123;</span><br><span class="line">        buffer.flip();</span><br><span class="line">        for (int i = 0; i &lt; buffer.limit(); i++) &#123;</span><br><span class="line">            //找到换行符的下标</span><br><span class="line">            //调用get(index)方法并不会改变position的位置</span><br><span class="line">            if (buffer.get(i) == &#x27;\n&#x27;)&#123;</span><br><span class="line">                StringBuilder builder = new StringBuilder();</span><br><span class="line">                //当前换行符前的字符长度，即需要取出的缓冲区长度</span><br><span class="line">                int length = i + 1 - buffer.position();</span><br><span class="line">                for (int j = 0; j &lt; length; j++) &#123;</span><br><span class="line">                    //取出buffer中的字符，get方法会使position+1</span><br><span class="line">                    builder.append((char)buffer.get());</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;string:&quot;+builder.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //调用compact，使缓冲区中未读取完的字符不会被清空</span><br><span class="line">        /*</span><br><span class="line">        例如Hello,world\nI&#x27;m Nyima\nHo</span><br><span class="line">        因为Ho后没有\n所以Ho不会被取出，compact会将Ho向前压缩，再第二次读取时就会组成How are you?\n</span><br><span class="line">         */</span><br><span class="line">        buffer.compact();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><ul>
<li><p>阻塞模式下，相关方法都会导致线程暂停</p>
<ul>
<li>ServerSocketChannel.accept 会在<strong>没有连接建立时</strong>让线程暂停</li>
<li>SocketChannel.read 会在<strong>通道中没有数据可读时</strong>让线程暂停</li>
<li>阻塞的表现其实就是线程暂停了，暂停期间不会占用 cpu，但线程相当于闲置</li>
</ul>
</li>
<li><p>单线程下，阻塞方法之间相互影响，几乎不能正常工作，需要多线程支持</p>
</li>
<li><p>但多线程下，有新的问题，体现在以下方面</p>
<ul>
<li>32 位 jvm 一个线程 320k，64 位 jvm 一个线程 1024k，如果连接数过多，必然导致 OOM，并且线程太多，反而会因为频繁上下文切换导致性能降低</li>
<li>可以采用线程池技术来减少线程数和线程上下文切换，但治标不治本，如果有很多连接建立，但长时间 inactive，会阻塞线程池中所有线程，因此不适合长连接，只适合短连接</li>
</ul>
</li>
</ul>
<h4 id="ServiceServer"><a href="#ServiceServer" class="headerlink" title="ServiceServer"></a>ServiceServer</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class ServerDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        //  使用nio</span><br><span class="line"></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(16);</span><br><span class="line">        // 创建服务端服务器</span><br><span class="line">        ServerSocketChannel server = ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">        // 绑定监听端口</span><br><span class="line">        server.bind(new InetSocketAddress(8080));</span><br><span class="line"></span><br><span class="line">        // 客户端连接accept</span><br><span class="line">        List&lt;SocketChannel&gt; channels = new ArrayList&lt;&gt;();</span><br><span class="line">        while (true)&#123;</span><br><span class="line">            System.out.println(&quot;waiting for connecting&quot;);</span><br><span class="line">            //用于客户端通信</span><br><span class="line">            //accept是阻塞方法，如果没有新的连接就会一直阻塞在此处</span><br><span class="line">            channels.add(server.accept());</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;client connected&quot;);</span><br><span class="line">            for (SocketChannel channel : channels) &#123;</span><br><span class="line">                System.out.println(&quot;before read&quot;);</span><br><span class="line">                // 接受客户端数据</span><br><span class="line">                channel.read(buffer);</span><br><span class="line"></span><br><span class="line">                // 切换到读模式</span><br><span class="line">                buffer.flip();</span><br><span class="line">                ByteBufferUtil.debugRead(buffer);</span><br><span class="line"></span><br><span class="line">                System.out.println(&quot;after read&quot;);</span><br><span class="line">                System.out.println();</span><br><span class="line">                //切换到写模式</span><br><span class="line">                buffer.clear();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ClientServer"><a href="#ClientServer" class="headerlink" title="ClientServer"></a>ClientServer</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class ClientDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        // 创建客户端服务器</span><br><span class="line">        SocketChannel client = SocketChannel.open();</span><br><span class="line"></span><br><span class="line">        // 进行连接</span><br><span class="line">        client.connect(new InetSocketAddress(&quot;localhost&quot;,8080));</span><br><span class="line"></span><br><span class="line">        client.write(Charset.defaultCharset().encode(&quot;Hello! Im client&quot;));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h3><ul>
<li>可以通过ServerSocketChannel的configureBlocking(<strong>false</strong>)方法将<strong>获得连接设置为非阻塞的</strong>。此时若没有连接，accept会返回null</li>
<li>可以通过SocketChannel的configureBlocking(<strong>false</strong>)方法将从通道中<strong>读取数据设置为非阻塞的</strong>。若此时通道中没有数据可读，read会返回-1</li>
</ul>
<h4 id="ServiceServer-1"><a href="#ServiceServer-1" class="headerlink" title="ServiceServer"></a>ServiceServer</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class ServerDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        // 创建缓冲区</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(16);</span><br><span class="line">        // 获得服务器通道</span><br><span class="line">        try(ServerSocketChannel server = ServerSocketChannel.open()) &#123;</span><br><span class="line">            // 为服务器通道绑定端口</span><br><span class="line">            server.bind(new InetSocketAddress(8080));</span><br><span class="line">            // 用户存放连接的集合</span><br><span class="line">            ArrayList&lt;SocketChannel&gt; channels = new ArrayList&lt;&gt;();</span><br><span class="line">            // 循环接收连接</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                // 设置为非阻塞模式，没有连接时返回null，不会阻塞线程</span><br><span class="line">                server.configureBlocking(false);</span><br><span class="line">                SocketChannel socketChannel = server.accept();</span><br><span class="line">                System.out.println(&quot;before connecting...&quot;);</span><br><span class="line">                // 通道不为空时才将连接放入到集合中</span><br><span class="line">                if (socketChannel != null) &#123;</span><br><span class="line">                    System.out.println(&quot;after connecting...&quot;);</span><br><span class="line">                    channels.add(socketChannel);</span><br><span class="line">                &#125;</span><br><span class="line">                // 循环遍历集合中的连接</span><br><span class="line">                for(SocketChannel channel : channels) &#123;</span><br><span class="line">                    // 处理通道中的数据</span><br><span class="line">                    // 设置为非阻塞模式，若通道中没有数据，会返回0，不会阻塞线程</span><br><span class="line">                    channel.configureBlocking(false);</span><br><span class="line">                    int read = channel.read(buffer);</span><br><span class="line">                    if(read &gt; 0) &#123;</span><br><span class="line">                        buffer.flip();</span><br><span class="line">                        ByteBufferUtil.debugRead(buffer);</span><br><span class="line">                        buffer.clear();</span><br><span class="line">                        System.out.println(&quot;after reading&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样写存在一个问题，因为设置为了非阻塞，会一直执行while(true)中的代码，CPU一直处于忙碌状态，会使得性能变低，所以实际情况中不使用这种方法处理请求</p>
<h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><p>单线程可以配合 Selector 完成对多个 Channel 可读写事件的监控，这称之为多路复用</p>
<ul>
<li><p><strong>多路复用仅针对网络 IO</strong>，普通文件 IO <strong>无法</strong>利用多路复用</p>
</li>
<li><p>如果不用 Selector 的非阻塞模式，线程大部分时间都在做无用功，而 Selector 能够保证</p>
<ul>
<li><p>有可连接事件时才去连接</p>
</li>
<li><p>有可读事件才去读取</p>
</li>
<li><p>有可写事件才去写入</p>
<ul>
<li>限于网络传输能力，Channel 未必时时可写，一旦 Channel 可写，会触发 Selector 的可写事件</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Accept事件"><a href="#Accept事件" class="headerlink" title="Accept事件"></a>Accept事件</h4> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class ServerDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(16);</span><br><span class="line">        // 获得服务器通道</span><br><span class="line">        try(ServerSocketChannel server = ServerSocketChannel.open()) &#123;</span><br><span class="line">            server.bind(new InetSocketAddress(8080));</span><br><span class="line">            // 创建选择器</span><br><span class="line">            Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">            // 通道必须设置为非阻塞模式</span><br><span class="line">            server.configureBlocking(false);</span><br><span class="line">            // 将通道注册到选择器中，并设置感兴趣的事件</span><br><span class="line">            server.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                // 若没有事件就绪，线程会被阻塞，反之不会被阻塞。从而避免了CPU空转</span><br><span class="line">                // 返回值为就绪的事件个数</span><br><span class="line">                int ready = selector.select();</span><br><span class="line">                System.out.println(&quot;selector ready counts : &quot; + ready);</span><br><span class="line"></span><br><span class="line">                // 获取所有事件</span><br><span class="line">                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line"></span><br><span class="line">                // 使用迭代器遍历事件</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">                while (iterator.hasNext()) &#123;</span><br><span class="line">                    SelectionKey key = iterator.next();</span><br><span class="line"></span><br><span class="line">                    // 判断key的类型</span><br><span class="line">                    if(key.isAcceptable()) &#123;</span><br><span class="line">                        // 获得key对应的channel</span><br><span class="line">                        ServerSocketChannel channel = (ServerSocketChannel) key.channel();</span><br><span class="line">                        System.out.println(&quot;before accepting...&quot;);</span><br><span class="line"></span><br><span class="line">                        // 获取连接并处理，而且是必须处理，否则需要取消</span><br><span class="line">                        SocketChannel socketChannel = channel.accept();</span><br><span class="line">                        System.out.println(&quot;after accepting...&quot;);</span><br><span class="line"></span><br><span class="line">                        // 处理完毕后移除</span><br><span class="line">                        iterator.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤解析</strong></p>
<ul>
<li>获得选择器Selector</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure>

<ul>
<li><p>将<strong>通道设置为非阻塞模式</strong>，并注册到选择器中，并设置感兴趣的事件</p>
<ul>
<li><p>channel 必须工作在非阻塞模式</p>
</li>
<li><p>FileChannel 没有非阻塞模式，因此不能配合 selector 一起使用</p>
</li>
<li><p>绑定的<strong>事件类型</strong>可以有</p>
<ul>
<li>connect - 客户端连接成功时触发</li>
<li>accept - 服务器端成功接受连接时触发</li>
<li>read - 数据可读入时触发，有因为接收能力弱，数据暂不能读入的情况</li>
<li>write - 数据可写出时触发，有因为发送能力弱，数据暂不能写出的情况</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 通道必须设置为非阻塞模式</span><br><span class="line">server.configureBlocking(false);</span><br><span class="line">// 将通道注册到选择器中，并设置感兴趣的事件</span><br><span class="line">server.register(selector, SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>通过Selector监听事件，并获得就绪的通道个数，若没有通道就绪，线程会被阻塞</p>
<ul>
<li><p>阻塞直到绑定事件发生</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int count = selector.select();</span><br></pre></td></tr></table></figure>
</li>
<li><p>阻塞直到绑定事件发生，<strong>或是超时</strong>（时间单位为 ms）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int count = selector.select(long timeout);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>不会阻塞</strong>，也就是不管有没有事件，立刻返回，自己根据返回值检查是否有事件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int count = selector.selectNow();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>获取就绪事件并<strong>得到对应的通道</strong>，然后进行处理</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 获取所有事件</span><br><span class="line">Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                </span><br><span class="line">// 使用迭代器遍历事件</span><br><span class="line">Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line"></span><br><span class="line">while (iterator.hasNext()) &#123;</span><br><span class="line">	SelectionKey key = iterator.next();</span><br><span class="line">                    </span><br><span class="line">	// 判断key的类型，此处为Accept类型</span><br><span class="line">	if(key.isAcceptable()) &#123;</span><br><span class="line">        // 获得key对应的channel</span><br><span class="line">        ServerSocketChannel channel = (ServerSocketChannel) key.channel();</span><br><span class="line"></span><br><span class="line">        // 获取连接并处理，而且是必须处理，否则需要取消</span><br><span class="line">        SocketChannel socketChannel = channel.accept();</span><br><span class="line"></span><br><span class="line">        // 处理完毕后移除</span><br><span class="line">        iterator.remove();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;Copy</span><br></pre></td></tr></table></figure>

<p><strong>事件发生后能否不处理</strong></p>
<p>事件发生后，<strong>要么处理，要么取消（cancel）</strong> ，不能什么都不做，<strong>否则下次该事件仍会触发</strong>，这是因为 nio 底层使用的是水平触发</p>
<h4 id="Read事件"><a href="#Read事件" class="headerlink" title="Read事件"></a>Read事件</h4><ul>
<li>在Accept事件中，若有客户端与服务器端建立了连接，<strong>需要将其对应的SocketChannel设置为非阻塞，并注册到选择其中</strong></li>
<li>添加Read事件，触发后进行读取操作</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public class SelectServer &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(16);</span><br><span class="line">        // 获得服务器通道</span><br><span class="line">        try(ServerSocketChannel server = ServerSocketChannel.open()) &#123;</span><br><span class="line">            server.bind(new InetSocketAddress(8080));</span><br><span class="line">            // 创建选择器</span><br><span class="line">            Selector selector = Selector.open();</span><br><span class="line">            // 通道必须设置为非阻塞模式</span><br><span class="line">            server.configureBlocking(false);</span><br><span class="line">            // 将通道注册到选择器中，并设置感兴趣的实践</span><br><span class="line">            server.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            // 为serverKey设置感兴趣的事件</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                // 若没有事件就绪，线程会被阻塞，反之不会被阻塞。从而避免了CPU空转</span><br><span class="line">                // 返回值为就绪的事件个数</span><br><span class="line">                int ready = selector.select();</span><br><span class="line">                System.out.println(&quot;selector ready counts : &quot; + ready);</span><br><span class="line">                // 获取所有事件</span><br><span class="line">                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                // 使用迭代器遍历事件</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">                while (iterator.hasNext()) &#123;</span><br><span class="line">                    SelectionKey key = iterator.next();</span><br><span class="line">                    // 判断key的类型</span><br><span class="line">                    if(key.isAcceptable()) &#123;</span><br><span class="line">                        // 获得key对应的channel</span><br><span class="line">                        ServerSocketChannel channel = (ServerSocketChannel) key.channel();</span><br><span class="line">                        System.out.println(&quot;before accepting...&quot;);</span><br><span class="line">                        // 获取连接</span><br><span class="line">                        SocketChannel socketChannel = channel.accept();</span><br><span class="line">                        System.out.println(&quot;after accepting...&quot;);</span><br><span class="line">                        // 设置为非阻塞模式，同时将连接的通道也注册到选择其中</span><br><span class="line">                        socketChannel.configureBlocking(false);</span><br><span class="line">                        socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                        // 处理完毕后移除</span><br><span class="line">                        iterator.remove();</span><br><span class="line">                    &#125; else if (key.isReadable()) &#123;</span><br><span class="line">                        SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line">                        System.out.println(&quot;before reading...&quot;);</span><br><span class="line">                        channel.read(buffer);</span><br><span class="line">                        System.out.println(&quot;after reading...&quot;);</span><br><span class="line">                        buffer.flip();</span><br><span class="line">                        ByteBufferUtil.debugRead(buffer);</span><br><span class="line">                        buffer.clear();</span><br><span class="line">                        // 处理完毕后移除</span><br><span class="line">                        iterator.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>当处理完一个事件后，一定要调用迭代器的remove方法移除对应事件，否则会出现错误</strong>。原因如下</p>
<p>以我们上面的 <strong>Read事件</strong> 的代码为例</p>
<ul>
<li><p>当调用了 server.register(selector, SelectionKey.OP_ACCEPT)后，Selector中维护了一个集合，<strong>用于存放SelectionKey以及其对应的通道</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// WindowsSelectorImpl 中的 SelectionKeyImpl数组</span><br><span class="line">private SelectionKeyImpl[] channelArray = new SelectionKeyImpl[8];Copy</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class SelectionKeyImpl extends AbstractSelectionKey &#123;</span><br><span class="line">    // Key对应的通道</span><br><span class="line">    final SelChImpl channel;</span><br><span class="line">    ...</span><br><span class="line">&#125;Copy</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210414192429.png"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70ae74562fbb4b318eb52f510b0b801b~tplv-k3u1fbpfcp-zoom-1.image"></a></p>
</li>
<li><p>当<strong>选择器中的通道对应的事件发生后</strong>，selecionKey会被放到另一个集合中，但是<strong>selecionKey不会自动移除</strong>，所以需要我们在处理完一个事件后，通过迭代器手动移除其中的selecionKey。否则会导致已被处理过的事件再次被处理，就会引发错误<a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210414193143.png"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5179898ec9c64325a74e0a72e1681da2~tplv-k3u1fbpfcp-zoom-1.image"></a></p>
</li>
</ul>
<h2 id="NIO-BIO"><a href="#NIO-BIO" class="headerlink" title="NIO BIO"></a>NIO BIO</h2><h2 id="Stream与Channel"><a href="#Stream与Channel" class="headerlink" title="Stream与Channel"></a>Stream与Channel<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#1%E3%80%81Stream%E4%B8%8EChannel"></a></h2><ul>
<li>stream 不会自动缓冲数据，channel 会利用系统提供的发送缓冲区、接收缓冲区（更为底层）</li>
<li>stream 仅支持阻塞 API，channel 同时支持阻塞、非阻塞 API，<strong>网络 channel 可配合 selector 实现多路复用</strong></li>
<li>二者<strong>均为全双工</strong>，即读写可以同时进行<ul>
<li>虽然Stream是单向流动的，但是它也是全双工的</li>
</ul>
</li>
</ul>
<h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#2%E3%80%81IO%E6%A8%A1%E5%9E%8B"></a></h2><ul>
<li><p><strong>同步</strong>：线程自己去获取结果（一个线程）</p>
<ul>
<li>例如：线程调用一个方法后，需要等待方法返回结果</li>
</ul>
</li>
<li><p><strong>异步</strong>：线程自己不去获取结果，而是由其它线程返回结果（至少两个线程）</p>
<ul>
<li>例如：线程A调用一个方法后，继续向下运行，运行结果由线程B返回</li>
</ul>
</li>
</ul>
<p>当调用一次 channel.<strong>read</strong> 或 stream.<strong>read</strong> 后，会由用户态切换至操作系统内核态来完成真正数据读取，而读取又分为两个阶段，分别为：</p>
<ul>
<li><p>等待数据阶段</p>
</li>
<li><p>复制数据阶段</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418151243.png"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c022c78f4174fcaaba370ce0e105648~tplv-k3u1fbpfcp-zoom-1.image"></a></p>
</li>
</ul>
<p>根据UNIX 网络编程 - 卷 I，IO模型主要有以下几种</p>
<h3 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a><a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#%E9%98%BB%E5%A1%9EIO" title="阻塞IO"></a>阻塞IO<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#%E9%98%BB%E5%A1%9EIO"></a></h3><p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418151605.png"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fbcfe71a0a484b39a88cef503b439d46~tplv-k3u1fbpfcp-zoom-1.image"></a></p>
<ul>
<li>用户线程进行read操作时，<strong>需要等待操作系统执行实际的read操作</strong>，此期间用户线程是被阻塞的，无法执行其他操作</li>
</ul>
<h3 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a><a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#%E9%9D%9E%E9%98%BB%E5%A1%9EIO" title="非阻塞IO"></a>非阻塞IO<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#%E9%9D%9E%E9%98%BB%E5%A1%9EIO"></a></h3><p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418152137.png"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c772b7242c54afba56f1568f5505a08~tplv-k3u1fbpfcp-zoom-1.image"></a></p>
<ul>
<li><p>用户线程<strong>在一个循环中一直调用read方法</strong>，若内核空间中还没有数据可读，立即返回</p>
<ul>
<li><strong>只是在等待阶段非阻塞</strong></li>
</ul>
</li>
<li><p>用户线程发现内核空间中有数据后，等待内核空间执行复制数据，待复制结束后返回结果</p>
</li>
</ul>
<h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a><a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-1" title="多路复用"></a>多路复用<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-1"></a></h3><p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418154208.png"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/270cdcfcad3e4c49b9ca894b3b4092fe~tplv-k3u1fbpfcp-zoom-1.image"></a></p>
<p><strong>Java中通过Selector实现多路复用</strong></p>
<ul>
<li>当没有事件是，调用select方法会被阻塞住</li>
<li>一旦有一个或多个事件发生后，就会处理对应的事件，从而实现多路复用</li>
</ul>
<p><strong>多路复用与阻塞IO的区别</strong></p>
<ul>
<li>阻塞IO模式下，<strong>若线程因accept事件被阻塞，发生read事件后，仍需等待accept事件执行完成后</strong>，才能去处理read事件</li>
<li>多路复用模式下，一个事件发生后，若另一个事件处于阻塞状态，不会影响该事件的执行</li>
</ul>
<h3 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a><a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#%E5%BC%82%E6%AD%A5IO" title="异步IO"></a>异步IO<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#%E5%BC%82%E6%AD%A5IO"></a></h3><p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418160106.png"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f783ddb84b94a5591e0786fb8d83b4d~tplv-k3u1fbpfcp-zoom-1.image"></a></p>
<ul>
<li>线程1调用方法后理解返回，<strong>不会被阻塞也不需要立即获取结果</strong></li>
<li>当方法的运行结果出来以后，由线程2将结果返回给线程1</li>
</ul>
<h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a><a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#3%E3%80%81%E9%9B%B6%E6%8B%B7%E8%B4%9D" title="3、零拷贝"></a>零拷贝<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#3%E3%80%81%E9%9B%B6%E6%8B%B7%E8%B4%9D"></a></h2><p><strong>零拷贝指的是数据无需拷贝到 JVM 内存中</strong>，同时具有以下三个优点</p>
<ul>
<li>更少的用户态与内核态的切换</li>
<li>不利用 cpu 计算，减少 cpu 缓存伪共享</li>
<li>零拷贝适合小文件传输</li>
</ul>
<h3 id="传统-IO-问题"><a href="#传统-IO-问题" class="headerlink" title="传统 IO 问题"></a><a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#%E4%BC%A0%E7%BB%9F-IO-%E9%97%AE%E9%A2%98" title="传统 IO 问题"></a>传统 IO 问题<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#%E4%BC%A0%E7%BB%9F-IO-%E9%97%AE%E9%A2%98"></a></h3><p>传统的 IO 将一个文件通过 socket 写出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">File f = new File(&quot;helloword/data.txt&quot;);</span><br><span class="line">RandomAccessFile file = new RandomAccessFile(file, &quot;r&quot;);</span><br><span class="line"></span><br><span class="line">byte[] buf = new byte[(int)f.length()];</span><br><span class="line">file.read(buf);</span><br><span class="line"></span><br><span class="line">Socket socket = ...;</span><br><span class="line">socket.getOutputStream().write(buf);Copy</span><br></pre></td></tr></table></figure>

<p><strong>内部工作流如下</strong></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418162306.png"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a9d5b85a8c10475d8fe9cbfb1822c44e~tplv-k3u1fbpfcp-zoom-1.image"></a></p>
<ul>
<li><p>Java 本身并不具备 IO 读写能力，因此 read 方法调用后，要从 Java 程序的<strong>用户态切换至内核态</strong>，去调用操作系统（Kernel）的读能力，将数据读入<strong>内核缓冲区</strong>。这期间用户线程阻塞，操作系统使用 DMA（Direct Memory Access）来实现文件读，其间也不会使用 CPU</p>
<p><code>DMA 也可以理解为硬件单元，用来解放 cpu 完成文件 IO</code></p>
</li>
<li><p>从<strong>内核态</strong>切换回<strong>用户态</strong>，将数据从<strong>内核缓冲区</strong>读入<strong>用户缓冲区</strong>（即 byte[] buf），这期间 <strong>CPU 会参与拷贝</strong>，无法利用 DMA</p>
</li>
<li><p>调用 write 方法，这时将数据从<strong>用户缓冲区</strong>（byte[] buf）写入 <strong>socket 缓冲区，CPU 会参与拷贝</strong></p>
</li>
<li><p>接下来要向网卡写数据，这项能力 Java 又不具备，因此又得从<strong>用户态</strong>切换至<strong>内核态</strong>，调用操作系统的写能力，使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 CPU</p>
</li>
</ul>
<p>可以看到中间环节较多，java 的 IO 实际不是物理设备级别的读写，而是缓存的复制，底层的真正读写是操作系统来完成的</p>
<ul>
<li>用户态与内核态的切换发生了 3 次，这个操作比较重量级</li>
<li>数据拷贝了共 4 次</li>
</ul>
<h3 id="NIO-优化"><a href="#NIO-优化" class="headerlink" title="NIO 优化"></a><a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#NIO-%E4%BC%98%E5%8C%96" title="NIO 优化"></a>NIO 优化<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#NIO-%E4%BC%98%E5%8C%96"></a></h3><p>通过 <strong>DirectByteBuf</strong></p>
<ul>
<li><p>ByteBuffer.allocate(10)</p>
<ul>
<li>底层对应 HeapByteBuffer，使用的还是 Java 内存</li>
</ul>
</li>
<li><p>ByteBuffer.<strong>allocateDirect</strong>(10)</p>
<ul>
<li>底层对应DirectByteBuffer，<strong>使用的是操作系统内存</strong></li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418162410.png"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/57a5e9aeb2bb46b781b4e81b11c431a0~tplv-k3u1fbpfcp-zoom-1.image"></a></p>
<p>大部分步骤与优化前相同，唯有一点：<strong>Java 可以使用 DirectByteBuffer 将堆外内存映射到 JVM 内存中来直接访问使用</strong></p>
<ul>
<li><p>这块内存不受 JVM 垃圾回收的影响，因此内存地址固定，有助于 IO 读写</p>
</li>
<li><p>Java 中的 DirectByteBuf 对象仅维护了此内存的虚引用，内存回收分成两步</p>
<ul>
<li><p>DirectByteBuffer 对象被垃圾回收，将虚引用加入引用队列</p>
<ul>
<li>当引用的对象ByteBuffer被垃圾回收以后，虚引用对象Cleaner就会被放入引用队列中，然后调用Cleaner的clean方法来释放直接内存</li>
<li>DirectByteBuffer 的释放底层调用的是 Unsafe 的 freeMemory 方法</li>
</ul>
</li>
<li><p>通过专门线程访问引用队列，根据虚引用释放堆外内存</p>
</li>
</ul>
</li>
<li><p><strong>减少了一次数据拷贝，用户态与内核态的切换次数没有减少</strong></p>
</li>
</ul>
<h3 id="进一步优化1"><a href="#进一步优化1" class="headerlink" title="进一步优化1"></a><a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BC%98%E5%8C%961" title="进一步优化1"></a>进一步优化1<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BC%98%E5%8C%961"></a></h3><p><strong>以下两种方式都是零拷贝</strong>，即无需将数据拷贝到用户缓冲区中（JVM内存中）</p>
<p>底层采用了 <strong>linux 2.1</strong> 后提供的 <strong>sendFile</strong> 方法，Java 中对应着两个 channel 调用 <strong>transferTo&#x2F;transferFrom</strong> 方法拷贝数据</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418162750.png"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dbf572cef10749c9b36859d3b7c5eeee~tplv-k3u1fbpfcp-zoom-1.image"></a></p>
<ul>
<li>Java 调用 transferTo 方法后，要从 Java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA将数据读入<strong>内核缓冲区</strong>，不会使用 CPU</li>
<li>数据从<strong>内核缓冲区</strong>传输到 <strong>socket 缓冲区</strong>，CPU 会参与拷贝</li>
<li>最后使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 CPU</li>
</ul>
<p>这种方法下</p>
<ul>
<li>只发生了1次用户态与内核态的切换</li>
<li>数据拷贝了 3 次</li>
</ul>
<h3 id="进一步优化2"><a href="#进一步优化2" class="headerlink" title="进一步优化2"></a><a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BC%98%E5%8C%962" title="进一步优化2"></a>进一步优化2<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BC%98%E5%8C%962"></a></h3><p><strong>linux 2.4</strong> 对上述方法再次进行了优化</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418163033.png"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2ada3cf2710433dbebf60630666fa8e~tplv-k3u1fbpfcp-zoom-1.image"></a></p>
<ul>
<li>Java 调用 transferTo 方法后，要从 Java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA将数据读入<strong>内核缓冲区</strong>，不会使用 CPU</li>
<li>只会将一些 offset 和 length 信息拷入 <strong>socket 缓冲区</strong>，几乎无消耗</li>
<li>使用 DMA 将 <strong>内核缓冲区</strong>的数据写入网卡，不会使用 CPU</li>
</ul>
<p><strong>整个过程仅只发生了1次用户态与内核态的切换，数据拷贝了 2 次</strong></p>
<h2 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a><a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#4%E3%80%81AIO" title="4、AIO"></a>AIO<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#4%E3%80%81AIO"></a></h2><p>AIO 用来解决数据复制阶段的阻塞问题</p>
<ul>
<li>同步意味着，在进行读写操作时，线程需要等待结果，还是相当于闲置</li>
<li>异步意味着，在进行读写操作时，线程不必等待结果，而是将来由操作系统来通过回调方式由另外的线程来获得结果</li>
</ul>
<blockquote>
<p>异步模型需要底层操作系统（Kernel）提供支持</p>
<ul>
<li>Windows 系统通过 IOCP <strong>实现了真正的异步 IO</strong></li>
<li>Linux 系统异步 IO 在 2.6 版本引入，但其<strong>底层实现还是用多路复用模拟了异步 IO，性能没有优势</strong></li>
</ul>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/09/23/NIO%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/" data-id="cl8e4gnyh0000upu5ceg717ex" data-title="NIO网络通信" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/09/23/NIO%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/">NIO网络通信</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>