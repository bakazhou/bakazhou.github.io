<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Bakazhou Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="blog by bakazhou">
<meta property="og:type" content="website">
<meta property="og:title" content="Bakazhou Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Bakazhou Blog">
<meta property="og:description" content="blog by bakazhou">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Bakazhou">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Bakazhou Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Bakazhou Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">welcome my blog</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Netty网络编程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/09/24/Netty%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2022-09-23T22:51:34.000Z" itemprop="datePublished">2022-09-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/09/24/Netty%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">Netty网络编程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Docs"><a href="#Docs" class="headerlink" title="Docs"></a>Docs</h1><ul>
<li>Netty官方文档:<a target="_blank" rel="noopener" href="https://netty.io/4.1/api/index.html">https://netty.io/4.1/api/index.html</a></li>
<li>Practice Repository:<a target="_blank" rel="noopener" href="https://github.com/bakazhou/JUC">https://github.com/bakazhou/JUC</a></li>
</ul>
<h1 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/25/Netty%E5%9F%BA%E7%A1%80/#Netty"></a></h1><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a><a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/25/Netty%E5%9F%BA%E7%A1%80/#%E4%B8%80%E3%80%81%E6%A6%82%E8%BF%B0" title="一、概述"></a>一、概述<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/25/Netty%E5%9F%BA%E7%A1%80/#%E4%B8%80%E3%80%81%E6%A6%82%E8%BF%B0"></a></h1><h2 id="1、什么是Netty"><a href="#1、什么是Netty" class="headerlink" title="1、什么是Netty"></a><a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/25/Netty%E5%9F%BA%E7%A1%80/#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFNetty" title="1、什么是Netty"></a>1、什么是Netty<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/25/Netty%E5%9F%BA%E7%A1%80/#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFNetty"></a></h2><pre class="line-numbers language-none"><code class="language-none">Netty is an asynchronous event-driven network application framework
for rapid development of maintainable high performance protocol servers &amp; clients.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>Netty 是一个异步的、基于事件驱动的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端</p>
<p><strong>注意</strong>：<code>netty的异步还是基于多路复用的，并没有实现真正意义上的异步IO</code></p>
<h2 id="2、Netty的优势"><a href="#2、Netty的优势" class="headerlink" title="2、Netty的优势"></a><a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/25/Netty%E5%9F%BA%E7%A1%80/#2%E3%80%81Netty%E7%9A%84%E4%BC%98%E5%8A%BF" title="2、Netty的优势"></a>2、Netty的优势<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/25/Netty%E5%9F%BA%E7%A1%80/#2%E3%80%81Netty%E7%9A%84%E4%BC%98%E5%8A%BF"></a></h2><p>如果使用传统NIO，其工作量大，bug 多</p>
<ul>
<li>需要自己构建协议</li>
<li>解决 TCP 传输问题，如粘包、半包</li>
<li>因为bug的存在，epoll 空轮询导致 CPU 100%</li>
</ul>
<p>Netty 对 API 进行增强，使之更易用，如</p>
<ul>
<li>FastThreadLocal &#x3D;&gt; ThreadLocal</li>
<li>ByteBuf &#x3D;&gt; ByteBuffer</li>
</ul>
<h1 id="二、入门案例"><a href="#二、入门案例" class="headerlink" title="二、入门案例"></a><a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/25/Netty%E5%9F%BA%E7%A1%80/#%E4%BA%8C%E3%80%81%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B" title="二、入门案例"></a>二、入门案例<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/25/Netty%E5%9F%BA%E7%A1%80/#%E4%BA%8C%E3%80%81%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B"></a></h1><h2 id="1、服务器端代码"><a href="#1、服务器端代码" class="headerlink" title="1、服务器端代码"></a><a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/25/Netty%E5%9F%BA%E7%A1%80/#1%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E4%BB%A3%E7%A0%81" title="1、服务器端代码"></a>1、服务器端代码<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/25/Netty%E5%9F%BA%E7%A1%80/#1%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E4%BB%A3%E7%A0%81"></a></h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloServer</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 1、启动器，负责装配netty组件，启动服务器</span>
        <span class="token keyword">new</span> <span class="token class-name">ServerBootstrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token comment">// 2、创建 NioEventLoopGroup，可以简单理解为 线程池 + Selector</span>
                <span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token comment">// 3、选择服务器的 ServerSocketChannel 实现</span>
                <span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token class-name">NioServerSocketChannel</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
                <span class="token comment">// 4、child 负责处理读写，该方法决定了 child 执行哪些操作</span>
            	<span class="token comment">// ChannelInitializer 处理器（仅执行一次）</span>
            	<span class="token comment">// 它的作用是待客户端SocketChannel建立连接后，执行initChannel以便添加更多的处理器</span>
                <span class="token punctuation">.</span><span class="token function">childHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChannelInitializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">NioSocketChannel</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    <span class="token annotation punctuation">@Override</span>
                    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">initChannel</span><span class="token punctuation">(</span><span class="token class-name">NioSocketChannel</span> nioSocketChannel<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>
                        <span class="token comment">// 5、SocketChannel的处理器，使用StringDecoder解码，ByteBuf=>String</span>
                        nioSocketChannel<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">StringDecoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token comment">// 6、SocketChannel的业务处理，使用上一个处理器的处理结果</span>
                        nioSocketChannel<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SimpleChannelInboundHandler</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                            <span class="token annotation punctuation">@Override</span>
                            <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">channelRead0</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> channelHandlerContext<span class="token punctuation">,</span> <span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>
                                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
                            <span class="token punctuation">&#125;</span>
                        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">&#125;</span>
                    <span class="token comment">// 7、ServerSocketChannel绑定8080端口</span>
                <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token number">8080</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="2、客户端代码"><a href="#2、客户端代码" class="headerlink" title="2、客户端代码"></a><a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/25/Netty%E5%9F%BA%E7%A1%80/#2%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%A3%E7%A0%81" title="2、客户端代码"></a>2、客户端代码<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/25/Netty%E5%9F%BA%E7%A1%80/#2%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%A3%E7%A0%81"></a></h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloClient</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">new</span> <span class="token class-name">Bootstrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token comment">// 选择客户 Socket 实现类，NioSocketChannel 表示基于 NIO 的客户端实现</span>
                <span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token class-name">NioSocketChannel</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
                <span class="token comment">// ChannelInitializer 处理器（仅执行一次）</span>
                <span class="token comment">// 它的作用是待客户端SocketChannel建立连接后，执行initChannel以便添加更多的处理器</span>
                <span class="token punctuation">.</span><span class="token function">handler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChannelInitializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Channel</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    <span class="token annotation punctuation">@Override</span>
                    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">initChannel</span><span class="token punctuation">(</span><span class="token class-name">Channel</span> channel<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>
                        <span class="token comment">// 消息会经过通道 handler 处理，这里是将 String => ByteBuf 编码发出</span>
                        channel<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">StringEncoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">&#125;</span>
                <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
                <span class="token comment">// 指定要连接的服务器和端口</span>
                <span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span><span class="token string">"localhost"</span><span class="token punctuation">,</span> <span class="token number">8080</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token comment">// Netty 中很多方法都是异步的，如 connect</span>
                <span class="token comment">// 这时需要使用 sync 方法等待 connect 建立连接完毕</span>
                <span class="token punctuation">.</span><span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token comment">// 获取 channel 对象，它即为通道抽象，可以进行数据读写操作</span>
                <span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token comment">// 写入消息并清空缓冲区</span>
                <span class="token punctuation">.</span><span class="token function">writeAndFlush</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="3、运行流程"><a href="#3、运行流程" class="headerlink" title="3、运行流程"></a><a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/25/Netty%E5%9F%BA%E7%A1%80/#3%E3%80%81%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B" title="3、运行流程"></a>3、运行流程<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/25/Netty%E5%9F%BA%E7%A1%80/#3%E3%80%81%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B"></a></h2><p><strong>左：客户端 右：服务器端</strong></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210420132155.png"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c904b7d6d574b33999c73e2afa072f1~tplv-k3u1fbpfcp-zoom-1.image"></a><br>Client发送数据，经过client自身的handler，将数据转为ByteBuf，server接收到数据后，通过server的handler将数据从byteBuf转为所需要的数据，并进行处理</p>
<h3 id="组件解释"><a href="#组件解释" class="headerlink" title="组件解释"></a><a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/25/Netty%E5%9F%BA%E7%A1%80/#%E7%BB%84%E4%BB%B6%E8%A7%A3%E9%87%8A" title="组件解释"></a>组件解释<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/25/Netty%E5%9F%BA%E7%A1%80/#%E7%BB%84%E4%BB%B6%E8%A7%A3%E9%87%8A"></a></h3><ul>
<li><p>channel 可以理解为数据的通道</p>
</li>
<li><p>msg 理解为流动的数据，最开始输入是 ByteBuf，但经过 pipeline 中的各个 handler 加工，会变成其它类型对象，最后输出又变成 ByteBuf</p>
</li>
<li><p>handler 可以理解为数据的处理工序</p>
<ul>
<li><p>工序有多道，<strong>合在一起就是 pipeline（传递途径）</strong> ，pipeline 负责发布事件（读、读取完成…）传播给每个 handler， handler 对自己感兴趣的事件进行处理（重写了相应事件处理方法）</p>
<ul>
<li>pipeline 中有多个 handler，处理时会依次调用其中的 handler</li>
</ul>
</li>
<li><p>handler 分 Inbound 和 Outbound 两类</p>
<ul>
<li>Inbound 入站</li>
<li>Outbound 出站</li>
</ul>
</li>
</ul>
</li>
<li><p>eventLoop 可以理解为处理数据的工人</p>
<ul>
<li>eventLoop 可以管理多个 channel 的 io 操作，并且一旦 eventLoop 负责了某个 channel，就<strong>会将其与channel进行绑定</strong>，以后该 channel 中的 io 操作都由该 eventLoop 负责</li>
<li>eventLoop 既可以执行 io 操作，<strong>也可以进行任务处理</strong>，每个 eventLoop 有自己的任务队列，队列里可以堆放多个 channel 的待处理任务，任务分为普通任务、定时任务</li>
<li>eventLoop 按照 pipeline 顺序，依次按照 handler 的规划（代码）处理数据，可以为每个 handler 指定不同的 eventLoop</li>
</ul>
</li>
</ul>
<h1 id="三、组件"><a href="#三、组件" class="headerlink" title="三、组件"></a>三、组件<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/25/Netty%E5%9F%BA%E7%A1%80/#%E4%B8%89%E3%80%81%E7%BB%84%E4%BB%B6"></a></h1><h2 id="1、EventLoop"><a href="#1、EventLoop" class="headerlink" title="1、EventLoop"></a><a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/25/Netty%E5%9F%BA%E7%A1%80/#1%E3%80%81EventLoop" title="1、EventLoop"></a>1、EventLoop<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/25/Netty%E5%9F%BA%E7%A1%80/#1%E3%80%81EventLoop"></a></h2><p><strong>事件循环对象</strong> EventLoop</p>
<p>EventLoop 本质是一个<strong>单线程执行器</strong>（同时<strong>维护了一个 Selector</strong>），里面有 run 方法处理一个或多个 Channel 上源源不断的 io 事件</p>
<p>它的继承关系如下</p>
<ul>
<li><p>继承自 j.u.c.ScheduledExecutorService 因此包含了线程池中所有的方法</p>
</li>
<li><p>继承自 netty 自己的 OrderedEventExecutor</p>
<ul>
<li>提供了 boolean inEventLoop(Thread thread) 方法判断一个线程是否属于此 EventLoop</li>
<li>提供了 EventLoopGroup parent() 方法来看看自己属于哪个 EventLoopGroup</li>
</ul>
</li>
</ul>
<p><strong>事件循环组</strong> EventLoopGroup</p>
<p>EventLoopGroup 是一组 EventLoop，Channel 一般会调用 EventLoopGroup 的 register 方法来绑定其中一个 EventLoop，后续这个 Channel 上的 io 事件都由此 EventLoop 来处理（保证了 io 事件处理时的线程安全）</p>
<ul>
<li><p>继承自 netty 自己的 EventExecutorGroup</p>
<ul>
<li>实现了 Iterable 接口提供遍历 EventLoop 的能力</li>
<li>另有 next 方法获取集合中下一个 EventLoop</li>
</ul>
</li>
</ul>
<h3 id="处理普通与定时任务"><a href="#处理普通与定时任务" class="headerlink" title="处理普通与定时任务"></a><a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/25/Netty%E5%9F%BA%E7%A1%80/#%E5%A4%84%E7%90%86%E6%99%AE%E9%80%9A%E4%B8%8E%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1" title="处理普通与定时任务"></a>处理普通与定时任务</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestEventLoop</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">//1 创建事件循环组</span>

        <span class="token comment">// io事件，普通任务，定时任务</span>
        <span class="token class-name">NioEventLoopGroup</span> nioEventLoopGroup <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//普通任务，定时任务</span>
        <span class="token class-name">DefaultEventLoopGroup</span> defaultEventLoopGroup <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultEventLoopGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">//2 获取事件循环对象</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>nioEventLoopGroup<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>nioEventLoopGroup<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>nioEventLoopGroup<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">//3 执行普通任务</span>
        nioEventLoopGroup<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ok"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">//4 定时任务</span>
        nioEventLoopGroup<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">scheduleAtFixedRate</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
        
        <span class="token comment">//5 关闭</span>
        nioEventLoopGroup<span class="token punctuation">.</span><span class="token function">shutdownGracefully</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>关闭 EventLoopGroup</strong><br>优雅关闭 <code>shutdownGracefully</code> 方法。该方法会首先切换 <code>EventLoopGroup</code> 到关闭状态从而拒绝新的任务的加入，然后在任务队列的任务都处理完成后，停止线程的运行。从而确保整体应用是在正常有序的状态下退出的</p>
<h3 id="处理IO任务"><a href="#处理IO任务" class="headerlink" title="处理IO任务"></a>处理IO任务<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/25/Netty%E5%9F%BA%E7%A1%80/#%E5%A4%84%E7%90%86IO%E4%BB%BB%E5%8A%A1"></a></h3><h4 id="服务器代码"><a href="#服务器代码" class="headerlink" title="服务器代码"></a>服务器代码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EventLoopServer</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

        <span class="token comment">// 只负责accept事件</span>
        <span class="token class-name">NioEventLoopGroup</span> boss <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">//负责read,write事件</span>
        <span class="token class-name">NioEventLoopGroup</span> worker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 对eventloop进行指责划分 分为boss和worker</span>
        <span class="token comment">// 此处划分为accept事件和read事件</span>
        <span class="token keyword">new</span> <span class="token class-name">ServerBootstrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
                <span class="token function">group</span><span class="token punctuation">(</span>boss<span class="token punctuation">,</span>worker<span class="token punctuation">)</span><span class="token punctuation">.</span>
                <span class="token comment">//NioServerSocketChannel只会和NioEventLoopGroup中的一个EventLoop绑定</span>
                <span class="token function">channel</span><span class="token punctuation">(</span><span class="token class-name">NioServerSocketChannel</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
                <span class="token function">childHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChannelInitializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">NioSocketChannel</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    <span class="token annotation punctuation">@Override</span>
                    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">initChannel</span><span class="token punctuation">(</span><span class="token class-name">NioSocketChannel</span> ch<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>
                        <span class="token comment">// 为handler设置指定的NioEventGroup</span>
                        ch<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span>worker<span class="token punctuation">,</span><span class="token string">"handleRead"</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">ChannelInboundHandlerAdapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                            <span class="token annotation punctuation">@Override</span>
                            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">channelRead</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">,</span> <span class="token class-name">Object</span> msg<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>
                                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>worker<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                                <span class="token class-name">ByteBuf</span> buffer <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ByteBuf</span><span class="token punctuation">)</span> msg<span class="token punctuation">;</span>
                                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>buffer<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token class-name">Charset</span><span class="token punctuation">.</span><span class="token function">defaultCharset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                            <span class="token punctuation">&#125;</span>
                        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">&#125;</span>
                <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
                <span class="token function">bind</span><span class="token punctuation">(</span><span class="token number">8080</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h4><pre class="line-numbers language-none"><code class="language-none">public class EventLoopClient &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        Channel client &#x3D; new Bootstrap()
                .group(new NioEventLoopGroup())
                &#x2F;&#x2F; 选择客户 Socket 实现类，NioSocketChannel 表示基于 NIO 的客户端实现
                .channel(NioSocketChannel.class)
                &#x2F;&#x2F; ChannelInitializer 处理器（仅执行一次）
                &#x2F;&#x2F; 它的作用是待客户端SocketChannel建立连接后，执行initChannel以便添加更多的处理器
                .handler(new ChannelInitializer&lt;&gt;() &#123;
                    @Override
                    protected void initChannel(Channel ch) throws Exception &#123;
                        &#x2F;&#x2F; 消息会经过通道 handler 处理，这里是将 String &#x3D;&gt; ByteBuf 编码发出
                        ch.pipeline().addLast(new StringEncoder());
                    &#125;
                &#125;)
                &#x2F;&#x2F; 指定要连接的服务器和端口
                .connect(new InetSocketAddress(&quot;localhost&quot;, 8080))
                &#x2F;&#x2F; Netty 中很多方法都是异步的，如 connect
                &#x2F;&#x2F; 这时需要使用 sync 方法等待 connect 建立连接完毕
                .sync()
                &#x2F;&#x2F; 获取 channel 对象，它即为通道抽象，可以进行数据读写操作
                .channel();
        client.writeAndFlush(&quot;hello\n&quot;);
        client.writeAndFlush(&quot;world\n&quot;);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="分工"><a href="#分工" class="headerlink" title="分工"></a>分工</h3><p>Bootstrap的group()方法<strong>可以传入两个EventLoopGroup参数</strong>，分别负责处理不同的事件</p>
<pre class="line-numbers language-none"><code class="language-none">public class MyServer &#123;
    public static void main(String[] args) &#123;
        new ServerBootstrap()
            	&#x2F;&#x2F; 两个Group，分别为Boss 负责Accept事件，Worker 负责读写事件
                .group(new NioEventLoopGroup(1), new NioEventLoopGroup(2))
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>一个EventLoop可以<strong>负责多个</strong>Channel，且EventLoop一旦与Channel绑定，则<strong>一直负责</strong>处理该Channel中的事件</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210421103251.png"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3443b295bdbc47d58617072e3101cdb6~tplv-k3u1fbpfcp-zoom-1.image"></a></p>
<h4 id="增加自定义EventLoopGroup"><a href="#增加自定义EventLoopGroup" class="headerlink" title="增加自定义EventLoopGroup"></a>增加自定义EventLoopGroup<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/25/Netty%E5%9F%BA%E7%A1%80/#%E5%A2%9E%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89EventLoopGroup"></a></h4><p>当有的<strong>任务需要较长的时间处理时，可以使用非NioEventLoopGroup</strong>，避免同一个NioEventLoop中的其他Channel在较长的时间内都无法得到处理</p>
<pre class="line-numbers language-none"><code class="language-none">public class MyServer &#123;
    public static void main(String[] args) &#123;
        &#x2F;&#x2F; 增加自定义的非NioEventLoopGroup
        EventLoopGroup group &#x3D; new DefaultEventLoopGroup();
        
        new ServerBootstrap()
                .group(new NioEventLoopGroup(1), new NioEventLoopGroup(2))
                .channel(NioServerSocketChannel.class)
                .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;
                    @Override
                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;
                        &#x2F;&#x2F; 增加两个handler，第一个使用NioEventLoopGroup处理，第二个使用自定义EventLoopGroup处理
                        socketChannel.pipeline().addLast(&quot;nioHandler&quot;,new ChannelInboundHandlerAdapter() &#123;
                            @Override
                            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;
                                ByteBuf buf &#x3D; (ByteBuf) msg;
                                System.out.println(Thread.currentThread().getName() + &quot; &quot; + buf.toString(StandardCharsets.UTF_8));
                                &#x2F;&#x2F; 调用下一个handler
                                ctx.fireChannelRead(msg);
                            &#125;
                        &#125;)
                        &#x2F;&#x2F; 该handler绑定自定义的Group
                        .addLast(group, &quot;myHandler&quot;, new ChannelInboundHandlerAdapter() &#123;
                            @Override
                            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;
                                ByteBuf buf &#x3D; (ByteBuf) msg;
                                System.out.println(Thread.currentThread().getName() + &quot; &quot; + buf.toString(StandardCharsets.UTF_8));
                            &#125;
                        &#125;);
                    &#125;
                &#125;)
                .bind(8080);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="切换的实现"><a href="#切换的实现" class="headerlink" title="切换的实现"></a>切换的实现<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/25/Netty%E5%9F%BA%E7%A1%80/#%E5%88%87%E6%8D%A2%E7%9A%84%E5%AE%9E%E7%8E%B0"></a></h4><p><strong>不同的EventLoopGroup切换的实现原理如下</strong></p>
<p>由上面的图可以看出，当handler中绑定的Group不同时，需要切换Group来执行不同的任务</p>
<pre class="line-numbers language-none"><code class="language-none">static void invokeChannelRead(final AbstractChannelHandlerContext next, Object msg) &#123;
    final Object m &#x3D; next.pipeline.touch(ObjectUtil.checkNotNull(msg, &quot;msg&quot;), next);
    &#x2F;&#x2F; 获得下一个EventLoop, excutor 即为 EventLoopGroup
    EventExecutor executor &#x3D; next.executor();
    
    &#x2F;&#x2F; 如果下一个EventLoop 在当前的 EventLoopGroup中
    if (executor.inEventLoop()) &#123;
        &#x2F;&#x2F; 使用当前 EventLoopGroup 中的 EventLoop 来处理任务
        next.invokeChannelRead(m);
    &#125; else &#123;
        &#x2F;&#x2F; 否则让另一个 EventLoopGroup 中的 EventLoop 来创建任务并执行
        executor.execute(new Runnable() &#123;
            public void run() &#123;
                next.invokeChannelRead(m);
            &#125;
        &#125;);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>如果两个 handler 绑定的是<strong>同一个EventLoopGroup</strong>，那么就直接调用</li>
<li>否则，把要调用的代码封装为一个任务对象，由下一个 handler 的 EventLoopGroup 来调用</li>
</ul>
<h2 id="2-Channel"><a href="#2-Channel" class="headerlink" title="2.Channel"></a>2.Channel</h2><h3 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h3><ul>
<li><p>close() 可以用来关闭Channel</p>
</li>
<li><p>closeFuture() 用来处理 Channel 的关闭</p>
<ul>
<li>sync 方法作用是同步等待 Channel 关闭</li>
<li>而 addListener 方法是异步等待 Channel 关闭</li>
</ul>
</li>
<li><p>pipeline() 方法用于添加处理器</p>
</li>
<li><p>write() 方法将数据写入</p>
<ul>
<li>因为缓冲机制，数据被写入到 Channel 中以后，不会立即被发送</li>
<li><strong>只有当缓冲满了或者调用了flush()方法后</strong>，才会将数据通过 Channel 发送出去</li>
</ul>
</li>
<li><p>writeAndFlush() 方法将数据写入并<strong>立即发送（刷出）</strong></p>
</li>
</ul>
<h3 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h3><p>带Future和Promise的类都是和异步方法配套使用的</p>
<pre class="line-numbers language-none"><code class="language-none">public class ChannelClient &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        ChannelFuture channelFuture &#x3D; new Bootstrap()
                .group(new NioEventLoopGroup())
                .channel(NioSocketChannel.class)
                .handler(new ChannelInitializer&lt;&gt;() &#123;
                    @Override
                    protected void initChannel(Channel ch) throws Exception &#123;
                        ch.pipeline().addLast(new StringEncoder());
                    &#125;
                &#125;)
                &#x2F;&#x2F;connect是异步非阻塞方法，在main函数中只是发起了调用，真正执行的是另一个nio线程，建立连接往往是需要消耗时间的，而如果不执行sync方法，就可能产生连接还没有建立成功，而主线程直接获取了channel
                &#x2F;&#x2F;，并进行了消息的发送
                .connect(new InetSocketAddress(&quot;localhost&quot;, 8080));

        channelFuture.sync();
        Channel channel &#x3D; channelFuture.channel();

        new Thread(() -&gt; &#123;
            Scanner scanner &#x3D; new Scanner(System.in);
            while (true)&#123;
                String input &#x3D; scanner.nextLine();
                if (input.equals(&quot;quit&quot;))&#123;
                    channel.close();
                    break;
                &#125;
                channel.writeAndFlush(input);
            &#125;
        &#125;).start();
        &#x2F;&#x2F;异步等待直到线程关闭
        ChannelFuture closeFuture &#x3D; channel.closeFuture();
        closeFuture.sync();
        
        &#x2F;&#x2F;线程已经关闭
        System.out.println(&quot;thread is closed&quot;);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="ChannelFuture连接问题"><a href="#ChannelFuture连接问题" class="headerlink" title="ChannelFuture连接问题"></a>ChannelFuture连接问题</h4><p>connect是异步非阻塞方法，在main函数中只是发起了调用，真正执行的是另一个nio线程，建立连接往往是需要消耗时间的，而如果不执行sync方法，就可能产生连接还没有建立成功，而主线程直接获取了channel，这个channel是没有建立连接的channel，所以消息并不能真正发送出去</p>
<h4 id="ChannelFuture关闭问题"><a href="#ChannelFuture关闭问题" class="headerlink" title="ChannelFuture关闭问题"></a>ChannelFuture关闭问题</h4><p>当我们要关闭channel时，可以调用channel.close()方法进行关闭。但是该方法也是一个<strong>异步方法</strong>。真正的关闭操作并不是在调用该方法的线程中执行的，而是<strong>在NIO线程中执行真正的关闭操作</strong></p>
<p>如果我们想在channel<strong>真正关闭以后</strong>，执行一些额外的操作，可以选择以下两种方法来实现</p>
<ul>
<li><p>通过channel.closeFuture()方法获得对应的ChannelFuture对象，然后调用<strong>sync()方法</strong>阻塞执行操作的线程，等待channel真正关闭后，再执行其他操作</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 获得closeFuture对象
ChannelFuture closeFuture &#x3D; channel.closeFuture();

&#x2F;&#x2F; 同步等待NIO线程执行完close操作
closeFuture.sync();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>调用<strong>closeFuture.addListener</strong>方法，添加close的后续操作</p>
<pre class="line-numbers language-none"><code class="language-none">closeFuture.addListener(new ChannelFutureListener() &#123;
    @Override
    public void operationComplete(ChannelFuture channelFuture) throws Exception &#123;
        &#x2F;&#x2F; 等待channel关闭后才执行的操作
        System.out.println(&quot;关闭之后执行一些额外操作...&quot;);
        &#x2F;&#x2F; 关闭EventLoopGroup
        group.shutdownGracefully();
    &#125;
&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h2 id="Handler-gt-Pipeline"><a href="#Handler-gt-Pipeline" class="headerlink" title="Handler -&gt; Pipeline"></a>Handler -&gt; Pipeline</h2><p>ChannelHandler用来处理Channel上的各种事件，分为入栈，出栈两种，所有的ChannelHandler连成一串就组成了Pipeline流水线</p>
<ul>
<li>入栈处理器通常是ChannelInBoundHandlerAdapter的子类，用来读取客户端数据，写回结果</li>
<li>出栈处理器通常是ChannelOutBoundHandlerAdapter的子类，主要对写回的结果进行加工<pre class="line-numbers language-none"><code class="language-none">public class PipeLineServer &#123;
    public static void main(String[] args) &#123;
        new ServerBootstrap()
                .group(new NioEventLoopGroup())
                .channel(NioServerSocketChannel.class)
                .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;
                    @Override
                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;
                        &#x2F;&#x2F; 在socketChannel的pipeline中添加handler
                        &#x2F;&#x2F; pipeline中handler是带有head与tail节点的双向链表，的实际结构为
                        &#x2F;&#x2F; head &lt;-&gt; handler1 &lt;-&gt; ... &lt;-&gt; handler4 &lt;-&gt;tail
                        &#x2F;&#x2F; Inbound主要处理入栈操作，一般为读操作，发生入栈操作时会触发Inbound方法
                        &#x2F;&#x2F; 入栈时，handler是从head向后调用的
                        socketChannel.pipeline().addLast(&quot;handler1&quot; ,new ChannelInboundHandlerAdapter() &#123;
                            @Override
                            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;
                                ByteBuf byteBuf &#x3D; (ByteBuf) msg;
                                String message &#x3D; byteBuf.toString(Charset.defaultCharset())+&quot; 1 &quot;;
                                System.out.println(&quot;handler1 msg:&quot;+message);
                                &#x2F;&#x2F; 父类该方法内部会调用fireChannelRead
                                &#x2F;&#x2F; 将数据传递给下一个handler
                                super.channelRead(ctx, message);
                            &#125;
                        &#125;);
                        socketChannel.pipeline().addLast(&quot;handler2&quot;, new ChannelInboundHandlerAdapter() &#123;
                            @Override
                            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;
                                String handle2 &#x3D; msg.toString()+&quot; 2 &quot;;
                                System.out.println(&quot;handler2 msg:&quot;+ handle2);
                                &#x2F;&#x2F; 执行write操作，使得Outbound的方法能够得到调用
                                socketChannel.writeAndFlush(ctx.alloc().buffer().writeBytes(&quot;Server...&quot;.getBytes(StandardCharsets.UTF_8)));
                                super.channelRead(ctx, handle2);
                            &#125;
                        &#125;);
                        &#x2F;&#x2F; Outbound主要处理出栈操作，一般为写操作，发生出栈操作时会触发Outbound方法
                        &#x2F;&#x2F; 出栈时，handler的调用是从tail向前调用的
                        socketChannel.pipeline().addLast(&quot;handler3&quot; ,new ChannelOutboundHandlerAdapter()&#123;
                            @Override
                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;
                                System.out.println(Thread.currentThread().getName() + &quot; Outbound handler 1&quot;);
                                super.write(ctx, msg, promise);
                            &#125;
                        &#125;);
                        socketChannel.pipeline().addLast(&quot;handler4&quot; ,new ChannelOutboundHandlerAdapter()&#123;
                            @Override
                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;
                                System.out.println(Thread.currentThread().getName() + &quot; Outbound handler 2&quot;);
                                super.write(ctx, msg, promise);
                            &#125;
                        &#125;);
                    &#125;
                &#125;)
                .bind(8080);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<p>通过channel.pipeline().addLast(name, handler)添加handler时，<strong>可以handler取名字</strong>。这样可以调用pipeline的<strong>addAfter、addBefore等方法更灵活地向pipeline中添加handler</strong></p>
<p>handler需要放入通道的pipeline中，才能根据放入顺序来使用handler</p>
<ul>
<li><p>pipeline是结构是一个带有head与tail指针的双向链表，其中的节点为handler</p>
<ul>
<li>要通过ctx.fireChannelRead(msg)等方法，<strong>将当前handler的处理结果传递给下一个handler</strong></li>
</ul>
</li>
<li><p>当有<strong>入栈</strong>（Inbound）操作时，会从<strong>head开始向后</strong>调用handler，直到handler不是处理Inbound操作为止</p>
</li>
<li><p>当有<strong>出栈</strong>（Outbound）操作时，会从<strong>tail开始向前</strong>调用handler，直到handler不是处理Outbound操作为止</p>
</li>
</ul>
<p><strong>具体结构如下</strong></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423102354.png"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/044a6fee057e420ba3cddb54cde7c589~tplv-k3u1fbpfcp-zoom-1.image"></a></p>
<p><strong>调用顺序如下</strong></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423105200.png"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68fe4167cfc74013a29b69e5d6f38d21~tplv-k3u1fbpfcp-zoom-1.image"></a></p>
<h3 id="OutboundHandler"><a href="#OutboundHandler" class="headerlink" title="OutboundHandler"></a><a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/25/Netty%E5%9F%BA%E7%A1%80/#OutboundHandler" title="OutboundHandler"></a>OutboundHandler<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/25/Netty%E5%9F%BA%E7%A1%80/#OutboundHandler"></a></h3><h4 id="socketChannel-writeAndFlush"><a href="#socketChannel-writeAndFlush" class="headerlink" title="socketChannel.writeAndFlush()"></a><a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/25/Netty%E5%9F%BA%E7%A1%80/#socketChannel-writeAndFlush" title="socketChannel.writeAndFlush()"></a>socketChannel.writeAndFlush()<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/25/Netty%E5%9F%BA%E7%A1%80/#socketChannel-writeAndFlush"></a></h4><p>当handler中调用该方法进行写操作时，会触发Outbound操作，<strong>此时是从tail向前寻找OutboundHandler</strong></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423122010.png"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d48c9618a2d42df8e85666a1795fee6~tplv-k3u1fbpfcp-zoom-1.image"></a></p>
<h4 id="ctx-writeAndFlush"><a href="#ctx-writeAndFlush" class="headerlink" title="ctx.writeAndFlush()"></a><a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/25/Netty%E5%9F%BA%E7%A1%80/#ctx-writeAndFlush" title="ctx.writeAndFlush()"></a>ctx.writeAndFlush()<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/25/Netty%E5%9F%BA%E7%A1%80/#ctx-writeAndFlush"></a></h4><p>当handler中调用该方法进行写操作时，会触发Outbound操作，<strong>此时是从当前handler向前寻找OutboundHandler</strong></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423122050.png"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4fc86abcbf3044198113d9234b095323~tplv-k3u1fbpfcp-zoom-1.image"></a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>EventLoop定义了Netty的核心对象，用于处理IO事件，多线程模型、并发，EventLoop, channel, Thread 以及 EventLoopGroup 之间的关系如下图：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9d4eb5f01fb40ecb6be9c36dab330f8~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>1、一个EventLoopGroup包含一个或者多个EventLoop;</p>
<p>2、一个EventLoop在它的生命周期内只和一个Thread绑定；</p>
<p>3、所有有EventLoop处理的I&#x2F;O事件都将在它专有的Thread上被处理；</p>
<p>4、一个Channel在它的生命周期内只注册于一个EventLoop;</p>
<p>5、一个EventLoop可能会被分配给一个或多个Channel；<br>其实我们可以简单的把EventLoop及其相关的实现NioEventLoop、NioEventLoopGroup等理解为netty针对我们网络编程时创建的多线程进行了封装和优化，构建了自己的线程模型。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="练习一-双向通信"><a href="#练习一-双向通信" class="headerlink" title="练习一 双向通信"></a>练习一 双向通信</h3><p>编写一个服务端和一个客户端，如果客户端给服务端发送ping，那么服务端会回复pong，同时客户端也要接收pong并打印</p>
<h4 id="服务端代码"><a href="#服务端代码" class="headerlink" title="服务端代码"></a>服务端代码</h4><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;实现一个双向通信，客户端发送ping，服务端回复pong
public class Server &#123;
    public static void main(String[] args) &#123;
        &#x2F;&#x2F; acceptWorker用于处理accept事件
        NioEventLoopGroup acceptWorker &#x3D; new NioEventLoopGroup();
        &#x2F;&#x2F; readWriteWorker用于处理read和write事件
        NioEventLoopGroup readWriteWorker &#x3D; new NioEventLoopGroup();
        ChannelFuture channelFuture &#x3D; new ServerBootstrap().
                &#x2F;&#x2F;设置为NioEventLoopGroup
                group(acceptWorker, readWriteWorker).
                channel(NioServerSocketChannel.class).
                childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;
                    @Override
                    protected void initChannel(NioSocketChannel socketChannel) throws Exception &#123;
                        &#x2F;&#x2F;readHandler 处理来自客户端的信息
                        socketChannel.pipeline().addLast(acceptWorker, &quot;readHandler&quot;, new ChannelInboundHandlerAdapter() &#123;
                            @Override
                            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;
                                ByteBuf byteBuf &#x3D; (ByteBuf) msg;
                                String message &#x3D; byteBuf.toString(Charset.defaultCharset());
                                System.out.println(message);
                                &#x2F;&#x2F;如果客户端信息为ping
                                if (&quot;ping&quot;.equals(message))&#123;
                                    &#x2F;&#x2F;触发writeHandler
                                    socketChannel.writeAndFlush(ctx.alloc().buffer().writeBytes(&quot;pong&quot;.getBytes()));
                                &#125;
                            &#125;
                        &#125;);

                        &#x2F;&#x2F;writeHandler 向客户端返回信息
                        socketChannel.pipeline().addLast(readWriteWorker, &quot;writeHandler&quot;, new ChannelOutboundHandlerAdapter() &#123;
                            @Override
                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;
                                ByteBuf byteBuf &#x3D; (ByteBuf) msg;
                                super.write(ctx, msg, promise);
                            &#125;
                        &#125;);
                    &#125;
                &#125;).
                bind(8080);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="客户端代码-1"><a href="#客户端代码-1" class="headerlink" title="客户端代码"></a>客户端代码</h4><pre class="line-numbers language-none"><code class="language-none">public class Client &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        NioEventLoopGroup worker &#x3D; new NioEventLoopGroup();
        ChannelFuture channelFuture &#x3D; new Bootstrap().
                group(worker).
                channel(NioSocketChannel.class).
                handler(new ChannelInitializer&lt;&gt;() &#123;
                    @Override
                    protected void initChannel(Channel ch) throws Exception &#123;
                        &#x2F;&#x2F;发送消息的处理器，对信息编码
                        ch.pipeline().addLast(new StringEncoder());
                        
                        &#x2F;&#x2F;处理服务端返回的数据
                        ch.pipeline().addLast(new ChannelInboundHandlerAdapter()&#123;
                            @Override
                            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;
                                ByteBuf buf &#x3D; (ByteBuf) msg;
                                System.out.println(buf.toString(Charset.defaultCharset()));
                                super.channelRead(ctx, msg);
                            &#125;
                        &#125;);
                    &#125;
                &#125;).connect(new InetSocketAddress(&quot;localhost&quot;, 8080));


        channelFuture.sync();
        Channel channel &#x3D; channelFuture.channel();


        new Thread(() -&gt; &#123;
            Scanner scanner &#x3D; new Scanner(System.in);
            while (true)&#123;
                String input &#x3D; scanner.nextLine();
                if (input.equals(&quot;quit&quot;))&#123;
                    channel.close();
                    break;
                &#125;
                channel.writeAndFlush(input);
            &#125;
        &#125;).start();
        &#x2F;&#x2F;异步等待直到线程关闭
        ChannelFuture closeFuture &#x3D; channel.closeFuture();
        closeFuture.sync();

        &#x2F;&#x2F;线程已经关闭
        System.out.println(&quot;thread is closed&quot;);
        worker.shutdownGracefully();
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="练习二-粘包半包"><a href="#练习二-粘包半包" class="headerlink" title="练习二 粘包半包"></a>练习二 粘包半包</h3><p>通过netty的方式解决粘包和半包的问题</p>
<h4 id="服务端代码-1"><a href="#服务端代码-1" class="headerlink" title="服务端代码"></a>服务端代码</h4><pre class="line-numbers language-none"><code class="language-none">@Slf4j
public class Server &#123;
    void start() &#123;
        NioEventLoopGroup boss &#x3D; new NioEventLoopGroup(1);
        NioEventLoopGroup worker &#x3D; new NioEventLoopGroup(1);
        try &#123;
            ServerBootstrap serverBootstrap &#x3D; new ServerBootstrap();
            serverBootstrap.channel(NioServerSocketChannel.class);
            &#x2F;&#x2F;设置系统接收缓冲区大小，复显半包的问题
            &#x2F;&#x2F;serverBootstrap.option(ChannelOption.SO_RCVBUF,10);
            &#x2F;&#x2F;serverBootstrap.option(ChannelOption.RCVBUF_ALLOCATOR,new FixedRecvByteBufAllocator(10));

            &#x2F;&#x2F;设置netty的缓冲区大小
            &#x2F;&#x2F;serverBootstrap.childOption(ChannelOption.RCVBUF_ALLOCATOR,new AdaptiveRecvByteBufAllocator(16,16,16));
            
            serverBootstrap.group(boss, worker);
            serverBootstrap.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;
                @Override
                protected void initChannel(SocketChannel ch) &#123;
                    ch.pipeline().addLast(worker,new LoggingHandler(LogLevel.INFO));
                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;

                        @Override
                        public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;
                            &#x2F;&#x2F; 连接建立时会执行该方法
                            super.channelActive(ctx);
                        &#125;

                        @Override
                        public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123;
                            &#x2F;&#x2F; 连接断开时会执行该方法
                            super.channelInactive(ctx);
                        &#125;
                    &#125;);
                &#125;
            &#125;);
            ChannelFuture channelFuture &#x3D; serverBootstrap.bind(8080);
            channelFuture.sync();
            &#x2F;&#x2F; 关闭channel
            channelFuture.channel().closeFuture().sync();
        &#125; catch (InterruptedException e) &#123;
            System.out.println(&quot;server error&quot;);
        &#125; finally &#123;
            boss.shutdownGracefully();
            worker.shutdownGracefully();
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        new Server().start();
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="客户端代码-2"><a href="#客户端代码-2" class="headerlink" title="客户端代码"></a>客户端代码</h4><pre class="line-numbers language-none"><code class="language-none">public class Client &#123;
    public static void main(String[] args) &#123;
        NioEventLoopGroup worker &#x3D; new NioEventLoopGroup();

        try &#123;
            Bootstrap bootstrap &#x3D; new Bootstrap();
            bootstrap.channel(NioSocketChannel.class);
            bootstrap.group(worker);
            bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;
                @Override
                protected void initChannel(SocketChannel ch) throws Exception &#123;
                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter()&#123;
                        @Override
                        public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;
                            &#x2F;*
                             分十次每次发送十个字节
                             期望服务端每次收到16个字节，一共收到十次
                             但是实际情况是服务端一次收到了160个字节
                             *&#x2F;
                            for (int i &#x3D; 0; i &lt; 10; i++) &#123;
                                ByteBuf byteBuf &#x3D; ctx.alloc().buffer(16);
                                byteBuf.writeBytes(new byte[]&#123;0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15&#125;);
                                ctx.writeAndFlush(byteBuf);

                            &#125;
                        &#125;
                    &#125;);
                &#125;
            &#125;);
            ChannelFuture channelFuture &#x3D; bootstrap.connect(&quot;localhost&quot;, 8080).sync();
            channelFuture.channel().closeFuture().sync();
        &#125; catch (InterruptedException e) &#123;
            System.out.println(&quot;client error&quot;);
        &#125; finally &#123;
            worker.shutdownGracefully();
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="粘包现象"><a href="#粘包现象" class="headerlink" title="粘包现象"></a>粘包现象</h4><p>客户端向服务端发送十次数据，一次16个字节，原本期望的情况是，服务端接收到十次，每次16字节，但是实际情况是服务端一次就接收到了160个字节，这就是粘包</p>
<pre class="line-numbers language-none"><code class="language-none">Sep 21, 2022 10:21:51 AM io.netty.handler.logging.LoggingHandler channelRegistered
INFO: [id: 0xd5093bd0, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:57243] REGISTERED
Sep 21, 2022 10:21:51 AM io.netty.handler.logging.LoggingHandler channelActive
INFO: [id: 0xd5093bd0, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:57243] ACTIVE
Sep 21, 2022 10:21:51 AM io.netty.handler.logging.LoggingHandler channelRead
INFO: [id: 0xd5093bd0, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:57243] READ: 160B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|
|00000010| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|
|00000020| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|
|00000030| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|
|00000040| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|
|00000050| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|
|00000060| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|
|00000070| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|
|00000080| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|
|00000090| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|
+--------+-------------------------------------------------+----------------+
Sep 21, 2022 10:21:51 AM io.netty.handler.logging.LoggingHandler channelReadComplete
INFO: [id: 0xd5093bd0, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:57243] READ COMPLETE
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="半包现象"><a href="#半包现象" class="headerlink" title="半包现象"></a>半包现象</h4><p>通过设置接收缓冲区的大小，从而限制接收方一次接收到的最大数据量，从而会对发送方的数据产生截断，这就是半包现象，只要使用TCP传输协议就一定会产生半包问题，而UDP不会</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;设置接收缓冲区大小，复显半包的问题
&#x2F;&#x2F;serverBootstrap.option(ChannelOption.SO_RCVBUF,10);
serverBootstrap.option(ChannelOption.RCVBUF_ALLOCATOR,new FixedRecvByteBufAllocator(3));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h4 id="现象分析"><a href="#现象分析" class="headerlink" title="现象分析"></a>现象分析</h4><p><strong>粘包</strong></p>
<ul>
<li><p>现象</p>
<ul>
<li>发送 abc def，接收 abcdef</li>
</ul>
</li>
<li><p>原因</p>
<ul>
<li><p>应用层</p>
<ul>
<li>接收方 ByteBuf 设置太大（Netty 默认 1024）</li>
</ul>
</li>
<li><p>传输层-网络层</p>
<ul>
<li>滑动窗口：假设发送方 256 bytes 表示一个完整报文，但由于接收方处理不及时且<strong>窗口大小足够大（大于256 bytes），这 256 bytes 字节就会缓冲在接收方的滑动窗口中，</strong> 当滑动窗口中缓冲了多个报文就会粘包</li>
<li>Nagle 算法：会造成粘包</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>半包</strong></p>
<ul>
<li><p>现象</p>
<ul>
<li>发送 abcdef，接收 abc def</li>
</ul>
</li>
<li><p>原因</p>
<ul>
<li><p>应用层</p>
<ul>
<li>接收方 ByteBuf 小于实际发送数据量</li>
</ul>
</li>
<li><p>传输层-网络层</p>
<ul>
<li>滑动窗口：假设接收方的窗口只剩了 128 bytes，发送方的报文大小是 256 bytes，这时<strong>接收方窗口中无法容纳发送方的全部报文，发送方只能先发送前 128 bytes，等待 ack 后才能发送剩余部分，这就造成了半包</strong></li>
</ul>
</li>
<li><p>数据链路层</p>
<ul>
<li>MSS 限制：当发送的数据超过 MSS 限制后，会将数据切分发送，就会造成半包</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="解决方案一-短连接"><a href="#解决方案一-短连接" class="headerlink" title="解决方案一 短连接"></a>解决方案一 短连接</h4><p><strong>客户端每次向服务器发送数据以后，就与服务器断开连接，此时的消息边界为连接建立到连接断开</strong>。这时便无需使用滑动窗口等技术来缓冲数据，则不会发生粘包现象。但如果一次性数据发送过多，接收方无法一次性容纳所有数据，还是会发生半包现象，所以<strong>短链接无法解决半包现象</strong></p>
<h5 id="短连接客户端代码"><a href="#短连接客户端代码" class="headerlink" title="短连接客户端代码"></a>短连接客户端代码</h5><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;通过短连接的方式解决粘包问题
public class ShortConnectClient &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        for (int i &#x3D; 0; i &lt; 10 ; i++) &#123;
            send();
            &#x2F;&#x2F;使发送变得有序
            Thread.sleep(1000);
        &#125;
    &#125;

    private static void send() &#123;
        NioEventLoopGroup worker &#x3D; new NioEventLoopGroup();

        try &#123;
            Bootstrap bootstrap &#x3D; new Bootstrap();
            bootstrap.channel(NioSocketChannel.class);
            bootstrap.group(worker);
            bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;
                @Override
                protected void initChannel(SocketChannel ch) throws Exception &#123;
                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;
                        @Override
                        public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;
                            ByteBuf byteBuf &#x3D; ctx.alloc().buffer(16);
                            byteBuf.writeBytes(new byte[]&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15&#125;);
                            ctx.writeAndFlush(byteBuf);
                            ctx.channel().close();
                        &#125;
                    &#125;);
                &#125;
            &#125;);
            ChannelFuture channelFuture &#x3D; bootstrap.connect(&quot;localhost&quot;, 8080).sync();
            channelFuture.channel().closeFuture().sync();
        &#125; catch (InterruptedException e) &#123;
            System.out.println(&quot;client error&quot;);
        &#125; finally &#123;
            worker.shutdownGracefully();
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h5><pre class="line-numbers language-none"><code class="language-none">Sep 21, 2022 10:56:41 AM io.netty.handler.logging.LoggingHandler channelRegistered
INFO: [id: 0x4f7f1e6b, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:57699] REGISTERED
Sep 21, 2022 10:56:41 AM io.netty.handler.logging.LoggingHandler channelActive
INFO: [id: 0x4f7f1e6b, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:57699] ACTIVE
Sep 21, 2022 10:56:41 AM io.netty.handler.logging.LoggingHandler channelRead
INFO: [id: 0x4f7f1e6b, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:57699] READ: 16B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|
+--------+-------------------------------------------------+----------------+
Sep 21, 2022 10:56:41 AM io.netty.handler.logging.LoggingHandler channelReadComplete
INFO: [id: 0x4f7f1e6b, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:57699] READ COMPLETE
Sep 21, 2022 10:56:41 AM io.netty.handler.logging.LoggingHandler channelReadComplete
INFO: [id: 0x4f7f1e6b, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:57699] READ COMPLETE
Sep 21, 2022 10:56:41 AM io.netty.handler.logging.LoggingHandler channelInactive
INFO: [id: 0x4f7f1e6b, L:&#x2F;127.0.0.1:8080 ! R:&#x2F;127.0.0.1:57699] INACTIVE
Sep 21, 2022 10:56:41 AM io.netty.handler.logging.LoggingHandler channelUnregistered
INFO: [id: 0x4f7f1e6b, L:&#x2F;127.0.0.1:8080 ! R:&#x2F;127.0.0.1:57699] UNREGISTERED
Sep 21, 2022 10:56:42 AM io.netty.handler.logging.LoggingHandler channelRegistered
INFO: [id: 0xb3ce3bc9, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:57700] REGISTERED
Sep 21, 2022 10:56:42 AM io.netty.handler.logging.LoggingHandler channelActive
INFO: [id: 0xb3ce3bc9, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:57700] ACTIVE
Sep 21, 2022 10:56:42 AM io.netty.handler.logging.LoggingHandler channelRead
INFO: [id: 0xb3ce3bc9, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:57700] READ: 16B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|
+--------+-------------------------------------------------+----------------+
Sep 21, 2022 10:56:42 AM io.netty.handler.logging.LoggingHandler channelReadComplete
INFO: [id: 0xb3ce3bc9, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:57700] READ COMPLETE
Sep 21, 2022 10:56:42 AM io.netty.handler.logging.LoggingHandler channelReadComplete
INFO: [id: 0xb3ce3bc9, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:57700] READ COMPLETE
Sep 21, 2022 10:56:42 AM io.netty.handler.logging.LoggingHandler channelInactive
INFO: [id: 0xb3ce3bc9, L:&#x2F;127.0.0.1:8080 ! R:&#x2F;127.0.0.1:57700] INACTIVE
Sep 21, 2022 10:56:42 AM io.netty.handler.logging.LoggingHandler channelUnregistered
INFO: [id: 0xb3ce3bc9, L:&#x2F;127.0.0.1:8080 ! R:&#x2F;127.0.0.1:57700] UNREGISTERED
...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="解决方案二-定长解码器"><a href="#解决方案二-定长解码器" class="headerlink" title="解决方案二 定长解码器"></a>解决方案二 定长解码器</h4><p>客户端与服务器<strong>约定一个最大长度，保证客户端每次发送的数据长度都不会大于该长度</strong>。若发送数据长度不足则需要<strong>补齐</strong>至该长度<br>服务器接收数据时，<strong>将接收到的数据按照约定的最大长度进行拆分</strong>，即使发送过程中产生了粘包，也可以通过定长解码器将数据正确地进行拆分。<strong>服务端需要用到<code>FixedLengthFrameDecoder</code>对数据进行定长解码</strong></p>
<h5 id="定长解码服务端代码"><a href="#定长解码服务端代码" class="headerlink" title="定长解码服务端代码"></a>定长解码服务端代码</h5><pre class="line-numbers language-none"><code class="language-none">@Slf4j
public class FixedLengthServer &#123;
    void start() &#123;
        NioEventLoopGroup boss &#x3D; new NioEventLoopGroup(1);
        NioEventLoopGroup worker &#x3D; new NioEventLoopGroup(1);
        try &#123;
            ServerBootstrap serverBootstrap &#x3D; new ServerBootstrap();
            serverBootstrap.channel(NioServerSocketChannel.class);;
            serverBootstrap.group(boss, worker);
            serverBootstrap.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;
                @Override
                protected void initChannel(SocketChannel ch) &#123;
                    &#x2F;&#x2F;通过定长解码器规定最大消息长度为10
                    ch.pipeline().addLast(new FixedLengthFrameDecoder(16));
                    ch.pipeline().addLast(worker,new LoggingHandler(LogLevel.INFO));
                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;

                        @Override
                        public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;
                            &#x2F;&#x2F; 连接建立时会执行该方法
                            super.channelActive(ctx);
                        &#125;

                        @Override
                        public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123;
                            &#x2F;&#x2F; 连接断开时会执行该方法
                            super.channelInactive(ctx);
                        &#125;
                    &#125;);
                &#125;
            &#125;);
            ChannelFuture channelFuture &#x3D; serverBootstrap.bind(8080);
            channelFuture.sync();
            &#x2F;&#x2F; 关闭channel
            channelFuture.channel().closeFuture().sync();
        &#125; catch (InterruptedException e) &#123;
            System.out.println(&quot;server error&quot;);
        &#125; finally &#123;
            boss.shutdownGracefully();
            worker.shutdownGracefully();
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        new FixedLengthServer().start();
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="定长解码器客户端代码"><a href="#定长解码器客户端代码" class="headerlink" title="定长解码器客户端代码"></a>定长解码器客户端代码</h5><pre class="line-numbers language-none"><code class="language-none">public class FixedLengthClient &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        send();
    &#125;

    private static void send() &#123;
        NioEventLoopGroup worker &#x3D; new NioEventLoopGroup();

        try &#123;
            Bootstrap bootstrap &#x3D; new Bootstrap();
            bootstrap.channel(NioSocketChannel.class);
            bootstrap.group(worker);
            bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;
                @Override
                protected void initChannel(SocketChannel ch) throws Exception &#123;
                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;
                        @Override
                        public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;
                            &#x2F;&#x2F; 约定最大长度为16
                            final int maxLength &#x3D; 16;
                            &#x2F;&#x2F; 被发送的数据
                            char c &#x3D; &#39;a&#39;;
                            &#x2F;&#x2F; 向服务器发送10个报文
                            for (int i &#x3D; 0; i &lt; 10; i++) &#123;
                                ByteBuf buffer &#x3D; ctx.alloc().buffer(maxLength);
                                &#x2F;&#x2F; 定长byte数组，未使用部分会以0进行填充
                                byte[] bytes &#x3D; new byte[maxLength];
                                &#x2F;&#x2F; 生成长度为0~15的数据
                                for (int j &#x3D; 0; j &lt; (int) (Math.random() * (maxLength - 1)); j++) &#123;
                                    bytes[j] &#x3D; (byte) c;
                                &#125;
                                buffer.writeBytes(bytes);
                                c++;
                                &#x2F;&#x2F; 将数据发送给服务器
                                ctx.writeAndFlush(buffer);
                            &#125;
                        &#125;
                    &#125;);
                &#125;
            &#125;);
            ChannelFuture channelFuture &#x3D; bootstrap.connect(&quot;localhost&quot;, 8080).sync();
            channelFuture.channel().closeFuture().sync();
        &#125; catch (InterruptedException e) &#123;
            System.out.println(&quot;client error&quot;);
        &#125; finally &#123;
            worker.shutdownGracefully();
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h5><pre class="line-numbers language-none"><code class="language-none">INFO: [id: 0x856d9368, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:57793] READ: 16B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 61 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |a...............|
+--------+-------------------------------------------------+----------------+
Sep 21, 2022 11:11:21 AM io.netty.handler.logging.LoggingHandler channelRead
INFO: [id: 0x856d9368, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:57793] READ: 16B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 62 62 62 62 00 00 00 00 00 00 00 00 00 00 00 00 |bbbb............|
+--------+-------------------------------------------------+----------------+
...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="解决方案三-LTC长度字段解码器"><a href="#解决方案三-LTC长度字段解码器" class="headerlink" title="解决方案三 LTC长度字段解码器"></a>解决方案三 LTC长度字段解码器</h4><p>在传送数据时可以在数据中<strong>添加一个用于表示有用数据长度的字段</strong>，在解码时读取出这个用于表明长度的字段，同时读取其他相关参数，即可知道最终需要的数据是什么样子的</p>
<p><code>LengthFieldBasedFrameDecoder</code>解码器可以提供更为丰富的拆分方法，其构造方法有五个参数</p>
<pre class="line-numbers language-none"><code class="language-none">public LengthFieldBasedFrameDecoder(
    int maxFrameLength,
    int lengthFieldOffset, int lengthFieldLength,
    int lengthAdjustment, int initialBytesToStrip)Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>参数解析</strong></p>
<ul>
<li><p>maxFrameLength 数据最大长度</p>
<ul>
<li>表示数据的最大长度（包括附加信息、长度标识等内容）</li>
</ul>
</li>
<li><p>lengthFieldOffset <strong>数据长度标识的起始偏移量</strong></p>
<ul>
<li>用于指明数据第几个字节开始是用于标识有用字节长度的，因为前面可能还有其他附加信息</li>
</ul>
</li>
<li><p>lengthFieldLength <strong>数据长度标识所占字节数</strong>（用于指明有用数据的长度）</p>
<ul>
<li>数据中用于表示有用数据长度的标识所占的字节数</li>
</ul>
</li>
<li><p>lengthAdjustment <strong>长度表示与有用数据的偏移量</strong></p>
<ul>
<li>用于指明数据长度标识和有用数据之间的距离，因为两者之间还可能有附加信息</li>
</ul>
</li>
<li><p>initialBytesToStrip <strong>数据读取起点</strong></p>
<ul>
<li>读取起点，<strong>不读取</strong> 0 ~ initialBytesToStrip 之间的数据</li>
</ul>
</li>
</ul>
<p><strong>参数图解</strong></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210425200007.png"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67cbff78c2d0455eb4932ba8a38c1717~tplv-k3u1fbpfcp-zoom-1.image"></a></p>
<pre class="line-numbers language-none"><code class="language-none">lengthFieldOffset   &#x3D; 0
lengthFieldLength   &#x3D; 2
lengthAdjustment    &#x3D; 0
initialBytesToStrip &#x3D; 0 (&#x3D; do not strip header)
  
BEFORE DECODE (14 bytes)         AFTER DECODE (14 bytes)
+--------+----------------+      +--------+----------------+
| Length | Actual Content |-----&gt;| Length | Actual Content |
| 0x000C | &quot;HELLO, WORLD&quot; |      | 0x000C | &quot;HELLO, WORLD&quot; |
+--------+----------------+      +--------+----------------+Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>从0开始即为长度标识，长度标识长度为2个字节</p>
<p><strong>0x000C</strong> 即为后面 <code>HELLO, WORLD</code>的长度</p>
<hr>
<pre class="line-numbers language-none"><code class="language-none">lengthFieldOffset   &#x3D; 0
lengthFieldLength   &#x3D; 2
lengthAdjustment    &#x3D; 0
initialBytesToStrip &#x3D; 2 (&#x3D; the length of the Length field)
  
BEFORE DECODE (14 bytes)         AFTER DECODE (12 bytes)
+--------+----------------+      +----------------+
| Length | Actual Content |-----&gt;| Actual Content |
| 0x000C | &quot;HELLO, WORLD&quot; |      | &quot;HELLO, WORLD&quot; |
+--------+----------------+      +----------------+Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>从0开始即为长度标识，长度标识长度为2个字节，<strong>读取时从第二个字节开始读取</strong>（此处即跳过长度标识）</p>
<p>因为<strong>跳过了用于表示长度的2个字节</strong>，所以此处直接读取<code>HELLO, WORLD</code></p>
<hr>
<pre class="line-numbers language-none"><code class="language-none">lengthFieldOffset   &#x3D; 2 (&#x3D; the length of Header 1)
lengthFieldLength   &#x3D; 3
lengthAdjustment    &#x3D; 0
initialBytesToStrip &#x3D; 0
  
BEFORE DECODE (17 bytes)                      AFTER DECODE (17 bytes)
+----------+----------+----------------+      +----------+----------+----------------+
| Header 1 |  Length  | Actual Content |-----&gt;| Header 1 |  Length  | Actual Content |
|  0xCAFE  | 0x00000C | &quot;HELLO, WORLD&quot; |      |  0xCAFE  | 0x00000C | &quot;HELLO, WORLD&quot; |
+----------+----------+----------------+      +----------+----------+----------------+Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>长度标识<strong>前面还有2个字节的其他内容</strong>（0xCAFE），第三个字节开始才是长度标识，长度表示长度为3个字节(0x00000C)</p>
<p>Header1中有附加信息，<strong>读取长度标识时需要跳过这些附加信息来获取长度</strong></p>
<hr>
<pre class="line-numbers language-none"><code class="language-none">lengthFieldOffset   &#x3D; 0
lengthFieldLength   &#x3D; 3
lengthAdjustment    &#x3D; 2 (&#x3D; the length of Header 1)
initialBytesToStrip &#x3D; 0
  
BEFORE DECODE (17 bytes)                      AFTER DECODE (17 bytes)
+----------+----------+----------------+      +----------+----------+----------------+
|  Length  | Header 1 | Actual Content |-----&gt;|  Length  | Header 1 | Actual Content |
| 0x00000C |  0xCAFE  | &quot;HELLO, WORLD&quot; |      | 0x00000C |  0xCAFE  | &quot;HELLO, WORLD&quot; |
+----------+----------+----------------+      +----------+----------+----------------+Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>从0开始即为长度标识，长度标识长度为3个字节，<strong>长度标识之后还有2个字节的其他内容</strong>（0xCAFE）</p>
<p>长度标识(0x00000C)表示的是**从其后lengthAdjustment（2个字节）开始的数据的长度，即<code>HELLO, WORLD</code>**，不包括0xCAFE</p>
<hr>
<pre class="line-numbers language-none"><code class="language-none">lengthFieldOffset   &#x3D; 1 (&#x3D; the length of HDR1)
lengthFieldLength   &#x3D; 2
lengthAdjustment    &#x3D; 1 (&#x3D; the length of HDR2)
initialBytesToStrip &#x3D; 3 (&#x3D; the length of HDR1 + LEN)
  
BEFORE DECODE (16 bytes)                       AFTER DECODE (13 bytes)
+------+--------+------+----------------+      +------+----------------+
| HDR1 | Length | HDR2 | Actual Content |-----&gt;| HDR2 | Actual Content |
| 0xCA | 0x000C | 0xFE | &quot;HELLO, WORLD&quot; |      | 0xFE | &quot;HELLO, WORLD&quot; |
+------+--------+------+----------------+      +------+----------------+Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>长度标识<strong>前面有1个字节的其他内容，后面也有1个字节的其他内容，读取时从长度标识之后3个字节处开始读取</strong>，即读取 <code>0xFE HELLO, WORLD</code></p>
<h5 id="客户端代码-3"><a href="#客户端代码-3" class="headerlink" title="客户端代码"></a>客户端代码</h5><pre class="line-numbers language-none"><code class="language-none">@Slf4j
public class LengthFieldDecoder &#123;
    public static void main(String[] args) &#123;
        &#x2F;&#x2F; 模拟服务器
        &#x2F;&#x2F; 使用EmbeddedChannel测试handler
        EmbeddedChannel channel &#x3D; new EmbeddedChannel(
                &#x2F;*
                   数据最大长度为1KB，长度标识前后各有1个字节的附加信息，长度标识长度为4个字节（int）
                   只获取其中的message信息 其他不需要
                   数据实际为
                            +-------------------------------------------------+
                                     |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
                            +--------+-------------------------------------------------+----------------+
                            |00000000| ca 00 00 00 05 fe 57 6f 72 6c 64                |......World     |
                            +--------+-------------------------------------------------+----------------+
                            0的位置是长度前的信息，占位一个字节，所以lengthFieldOffset需要设置为1，从1的位置开始读取信息长度
                            1-4是长度信息，int类型占位四个字节，所以lengthFieldLength需要设置为4
                            5的位置为实际信息前的额外数据，所以lengthAdjustment需要设置为1，表明其后1位开始才是实际信息
                            6-a的位置是实际信息，如果想解码取出实际信息，initialBytesToStrip设置为6，因为前面的多余信息所占字节数为1+4+1&#x3D;6
                 *&#x2F;
                new LengthFieldBasedFrameDecoder(1024, 1, 4, 1, 6),
                new LoggingHandler(LogLevel.INFO)
        );

        &#x2F;&#x2F; 模拟客户端，写入数据
        ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.buffer();
        send(buffer, &quot;Helloooooooo&quot;);
        channel.writeInbound(buffer);
        send(buffer, &quot;World&quot;);
        channel.writeInbound(buffer);
    &#125;

    private static void send(ByteBuf buf, String msg) &#123;
        &#x2F;&#x2F; 得到数据的长度
        int length &#x3D; msg.length();
        byte[] bytes &#x3D; msg.getBytes(StandardCharsets.UTF_8);
        &#x2F;&#x2F; 将数据信息写入buf
        &#x2F;&#x2F; 写入长度标识前的其他信息 占一个字节
        buf.writeByte(0xCA);
        &#x2F;&#x2F; 写入数据长度标识 一个int占四个字节
        buf.writeInt(length);
        &#x2F;&#x2F; 写入长度标识后的其他信息 占一个字节
        buf.writeByte(0xFE);
        &#x2F;&#x2F; 写入具体的数据
        buf.writeBytes(bytes);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="运行结果-2"><a href="#运行结果-2" class="headerlink" title="运行结果"></a>运行结果</h5><pre class="line-numbers language-none"><code class="language-none">INFO: [id: 0xembedded, L:embedded - R:embedded] READ: 12B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 48 65 6c 6c 6f 6f 6f 6f 6f 6f 6f 6f             |Helloooooooo    |
+--------+-------------------------------------------------+----------------+
Sep 21, 2022 2:00:15 PM io.netty.handler.logging.LoggingHandler channelReadComplete
INFO: [id: 0xembedded, L:embedded - R:embedded] READ COMPLETE
Sep 21, 2022 2:00:15 PM io.netty.handler.logging.LoggingHandler channelRead
INFO: [id: 0xembedded, L:embedded - R:embedded] READ: 5B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 57 6f 72 6c 64                                  |World           |
+--------+-------------------------------------------------+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="问题1-系统缓冲区大小设置无效"><a href="#问题1-系统缓冲区大小设置无效" class="headerlink" title="问题1.系统缓冲区大小设置无效"></a>问题1.系统缓冲区大小设置无效</h4><p>原想通过以下代码，强行设置系统接收缓冲区的大小为10，从而复现半包的问题，但是实际发现并不可行，其原因是<a target="_blank" rel="noopener" href="https://github.com/netty/netty/issues/6832">issue</a>，由于不同os的差异，实际上这个参数未必会和设置的一样，最终缓冲区大小还是由os决定的，netty的默认大小是1024B。</p>
<pre class="line-numbers language-none"><code class="language-none">serverBootstrap.option(ChannelOption.SO_RCVBUF,10);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">serverBootstrap.option(ChannelOption.RCVBUF_ALLOCATOR,new FixedRecvByteBufAllocator(8));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="练习三-协议设计与解析"><a href="#练习三-协议设计与解析" class="headerlink" title="练习三 协议设计与解析"></a>练习三 协议设计与解析</h3><h4 id="Redis协议"><a href="#Redis协议" class="headerlink" title="Redis协议"></a>Redis协议</h4><p>如果我们要向Redis服务器发送一条<code>set name TianLe Zhou</code>的指令，需要遵守如下协议</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 代表该指令一共有3部分，每条指令之后都要添加回车与换行符
*3\r\n
&#x2F;&#x2F; 第一个指令的长度是3
$3\r\n
&#x2F;&#x2F; 第一个指令是set指令
set\r\n
&#x2F;&#x2F; 下面的指令以此类推
$4\r\n
name\r\n
$11\r\n
TianLe Zhou\r\n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="客户端代码-4"><a href="#客户端代码-4" class="headerlink" title="客户端代码"></a>客户端代码</h5><pre class="line-numbers language-none"><code class="language-none">public class RedisClient &#123;
    &#x2F;*
        *3
        $3
        set
        $4
        name
        $11
        TianLe Zhou
     *&#x2F;
    public static void main(String[] args) &#123;
        final byte[] FORMAT &#x3D; &quot;\r\n&quot;.getBytes();
        NioEventLoopGroup worker &#x3D; new NioEventLoopGroup();
        try &#123;
            Bootstrap bootstrap &#x3D; new Bootstrap();
            bootstrap.channel(NioSocketChannel.class);
            bootstrap.group(worker);
            bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;
                @Override
                protected void initChannel(SocketChannel ch) throws Exception &#123;
                    ch.pipeline().addLast(worker,new LoggingHandler(LogLevel.INFO));
                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter()&#123;
                        @Override
                        public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;
                            ByteBuf buffer &#x3D; ctx.alloc().buffer();
                            buffer.writeBytes(&quot;*3&quot;.getBytes());
                            buffer.writeBytes(FORMAT);

                            buffer.writeBytes(&quot;$3&quot;.getBytes());
                            buffer.writeBytes(FORMAT);
                            buffer.writeBytes(&quot;set&quot;.getBytes());
                            buffer.writeBytes(FORMAT);

                            buffer.writeBytes(&quot;$4&quot;.getBytes());
                            buffer.writeBytes(FORMAT);
                            buffer.writeBytes(&quot;name&quot;.getBytes());
                            buffer.writeBytes(FORMAT);

                            buffer.writeBytes(&quot;$11&quot;.getBytes());
                            buffer.writeBytes(FORMAT);
                            buffer.writeBytes(&quot;TianLe Zhou&quot;.getBytes());
                            buffer.writeBytes(FORMAT);

                            &#x2F;&#x2F; 发送命令给Redis执行
                            ctx.channel().writeAndFlush(buffer);
                        &#125;

                        &#x2F;&#x2F;获取Redis返回的结果
                        @Override
                        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;
                            ByteBuf buf &#x3D; (ByteBuf) msg;
                            System.out.println(buf.toString(Charset.defaultCharset()));
                        &#125;
                    &#125;);
                &#125;
            &#125;);
            &#x2F;&#x2F; 连接到redis
            ChannelFuture channelFuture &#x3D; bootstrap.connect(new InetSocketAddress(&quot;localhost&quot;, 6379)).sync();
            channelFuture.channel().closeFuture().sync();
        &#125; catch (InterruptedException e) &#123;
            System.out.println(&quot;client error&quot;);
        &#125; finally &#123;
            worker.shutdownGracefully();
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="运行结果-3"><a href="#运行结果-3" class="headerlink" title="运行结果"></a>运行结果</h5><pre class="line-numbers language-none"><code class="language-none">INFO: [id: 0xd679c3af, L:&#x2F;127.0.0.1:59257 - R:localhost&#x2F;127.0.0.1:6379] WRITE: 41B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 2a 33 0d 0a 24 33 0d 0a 73 65 74 0d 0a 24 34 0d |*3..$3..set..$4.|
|00000010| 0a 6e 61 6d 65 0d 0a 24 31 31 0d 0a 54 69 61 6e |.name..$11..Tian|
|00000020| 4c 65 20 5a 68 6f 75 0d 0a                      |Le Zhou..       |
+--------+-------------------------------------------------+----------------+
Sep 21, 2022 2:26:19 PM io.netty.handler.logging.LoggingHandler flush
INFO: [id: 0xd679c3af, L:&#x2F;127.0.0.1:59257 - R:localhost&#x2F;127.0.0.1:6379] FLUSH
Sep 21, 2022 2:26:19 PM io.netty.handler.logging.LoggingHandler channelRead
INFO: [id: 0xd679c3af, L:&#x2F;127.0.0.1:59257 - R:localhost&#x2F;127.0.0.1:6379] READ: 5B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 2b 4f 4b 0d 0a                                  |+OK..           |
+--------+-------------------------------------------------+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="自定义协议"><a href="#自定义协议" class="headerlink" title="自定义协议"></a>自定义协议</h4><h5 id="组成要素"><a href="#组成要素" class="headerlink" title="组成要素"></a>组成要素</h5><ul>
<li><p><strong>魔数</strong>：作为判定协议是否有效的依据，例如Java起始字节码是CAFEBABE</p>
</li>
<li><p><strong>版本号</strong>：可以支持协议的升级</p>
</li>
<li><p><strong>序列化算法</strong>：消息正文到底采用哪种序列化反序列化方式</p>
<ul>
<li>如：json、protobuf、hessian、jdk</li>
</ul>
</li>
<li><p><strong>指令类型</strong>：与业务相关</p>
</li>
<li><p><strong>请求序号</strong>：为了双工通信，提供异步能力</p>
</li>
<li><p><strong>正文长度</strong></p>
</li>
<li><p><strong>消息正文</strong>：序列化，一般是json</p>
</li>
</ul>
<h5 id="自定义编解码协议实现"><a href="#自定义编解码协议实现" class="headerlink" title="自定义编解码协议实现"></a>自定义编解码协议实现</h5><p><strong>编解码器代码</strong></p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;通过泛型制定编解码的对象
public class MessageCodec extends ByteToMessageCodec&lt;Message&gt; &#123;

    &#x2F;&#x2F;出栈时进行编码
    @Override
    protected void encode(ChannelHandlerContext ctx, Message msg, ByteBuf out) throws Exception &#123;
        &#x2F;&#x2F;魔数 BAKAZHOU 占八个字节
        out.writeBytes(&quot;BAKAZHOU&quot;.getBytes());

        &#x2F;&#x2F;版本 1 占四个字节
        out.writeInt(1);
        &#x2F;&#x2F;序列化算法  0代表Json 1代表jdk 占四个字节
        out.writeInt(0);

        &#x2F;&#x2F;指令类型 int类型占四个字节
        out.writeInt(msg.getMessageType());

        &#x2F;&#x2F;请求序号 占四个字节
        out.writeInt(msg.getSequenceId());

        &#x2F;&#x2F;将消息正文站位bytes
        ByteArrayOutputStream bos &#x3D; new ByteArrayOutputStream();
        ObjectOutputStream oos &#x3D; new ObjectOutputStream(bos);
        oos.writeObject(msg);
        byte[] msgBytes &#x3D; bos.toByteArray();

        &#x2F;&#x2F;正文长度 占四个字节
        out.writeInt(msgBytes.length);

        &#x2F;&#x2F;正文前一共有28个字节
        &#x2F;&#x2F;写入正文
        out.writeBytes(msgBytes);
    &#125;

    &#x2F;&#x2F;入栈时进行解码
    @Override
    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception &#123;
        &#x2F;&#x2F;魔数 BAKAZHOU 8字节
        String magicNum &#x3D; in.readBytes(8).toString(Charset.defaultCharset());

        &#x2F;&#x2F;版本号 4字节
        int version &#x3D; in.readInt();

        &#x2F;&#x2F;序列化算法 
        int serializationAlgorithm &#x3D; in.readInt();

        int messageType &#x3D; in.readInt();

        &#x2F;&#x2F;请求序号
        int sequenceId &#x3D; in.readInt();

        &#x2F;&#x2F;正文长度
        int length &#x3D; in.readInt();

        &#x2F;&#x2F;正文内容
        byte[] msg &#x3D; new byte[length];
        in.readBytes(msg,0,length);
        &#x2F;&#x2F;判断序列化方式
        switch (serializationAlgorithm)&#123;
            case 0:
                ObjectInputStream ois &#x3D; new ObjectInputStream(new ByteArrayInputStream(msg));
                Message message &#x3D; (Message) ois.readObject();

                &#x2F;&#x2F;传给下一个处理器使用
                out.add(message);
                break;
            case 1:
                break;
            default:
                break;
        &#125;

    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><p>编码器与解码器方法源于<strong>父类ByteToMessageCodec</strong>，通过该类可以自定义编码器与解码器，<strong>泛型类型为被编码与被解码的类</strong>。此处使用了自定义类Message，代表消息</p>
<pre class="line-numbers language-none"><code class="language-none">public class MessageCodec extends ByteToMessageCodec&lt;Message&gt;Copy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>编码器<strong>负责将附加信息与正文信息写入到ByteBuf中</strong>，其中附加信息<strong>总字节数最好为2n，不足需要补齐</strong>。正文内容如果为对象，需要通过<strong>序列化</strong>将其放入到ByteBuf中</p>
</li>
<li><p>解码器<strong>负责将ByteBuf中的信息取出，并放入List中</strong>，该List用于将信息传递给下一个handler</p>
</li>
</ul>
<p><strong>测试代码</strong></p>
<pre class="line-numbers language-none"><code class="language-none">@Slf4j
public class TestMessageCodec &#123;
    public static void main(String[] args) throws Exception &#123;
        MessageCodec messageCodec &#x3D; new MessageCodec();
        EmbeddedChannel channel &#x3D; new EmbeddedChannel(
                &#x2F;&#x2F; 添加解码器，避免粘包半包问题
                new LengthFieldBasedFrameDecoder(1024, 28, 4, 4, 0),
                new LoggingHandler(LogLevel.INFO),
                messageCodec);

        &#x2F;&#x2F;encode
        LoginRequestMessage loginUser &#x3D; new LoginRequestMessage(&quot;bakazhou&quot;, &quot;123456&quot;);
        channel.writeOutbound(loginUser);

        ByteBuf byteBuf &#x3D; ByteBufAllocator.DEFAULT.buffer();
        System.out.println(byteBuf);
        messageCodec.encode(null, loginUser, byteBuf);
        channel.writeInbound(loginUser);
        System.out.println(byteBuf);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>运行结果</strong></p>
<pre class="line-numbers language-none"><code class="language-none">第一行0-7的位置即为魔数BAKAZHOU
第一行8-b为版本号
....
以此类推
INFO: [id: 0xembedded, L:embedded - R:embedded] WRITE: 285B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 42 41 4b 41 5a 48 4f 55 00 00 00 01 00 00 00 00 |BAKAZHOU........|
|00000010| 00 00 00 00 00 00 00 00 00 00 01 01 ac ed 00 05 |................|
|00000020| 73 72 00 41 63 6f 6d 2e 63 6e 2e 74 77 2e 67 72 |sr.Acom.cn.tw.gr|
|00000030| 61 64 75 61 74 65 2e 62 61 6b 61 7a 68 6f 75 2e |aduate.bakazhou.|
|00000040| 50 72 61 63 74 69 63 65 33 2e 6d 65 73 73 61 67 |Practice3.messag|
|00000050| 65 2e 4c 6f 67 69 6e 52 65 71 75 65 73 74 4d 65 |e.LoginRequestMe|
|00000060| 73 73 61 67 65 76 36 80 36 45 1a d9 d3 02 00 02 |ssagev6.6E......|
|00000070| 4c 00 08 70 61 73 73 77 6f 72 64 74 00 12 4c 6a |L..passwordt..Lj|
|00000080| 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b |ava&#x2F;lang&#x2F;String;|
|00000090| 4c 00 08 75 73 65 72 6e 61 6d 65 71 00 7e 00 01 |L..usernameq.~..|
|000000a0| 78 72 00 35 63 6f 6d 2e 63 6e 2e 74 77 2e 67 72 |xr.5com.cn.tw.gr|
|000000b0| 61 64 75 61 74 65 2e 62 61 6b 61 7a 68 6f 75 2e |aduate.bakazhou.|
|000000c0| 50 72 61 63 74 69 63 65 33 2e 6d 65 73 73 61 67 |Practice3.messag|
|000000d0| 65 2e 4d 65 73 73 61 67 65 d6 50 c5 58 ac 0f 63 |e.Message.P.X..c|
|000000e0| 63 02 00 02 49 00 0b 6d 65 73 73 61 67 65 54 79 |c...I..messageTy|
|000000f0| 70 65 49 00 0a 73 65 71 75 65 6e 63 65 49 64 78 |peI..sequenceIdx|
|00000100| 70 00 00 00 00 00 00 00 00 74 00 06 31 32 33 34 |p........t..1234|
|00000110| 35 36 74 00 08 62 61 6b 61 7a 68 6f 75          |56t..bakazhou   |
+--------+-------------------------------------------------+----------------+


PooledUnsafeDirectByteBuf(ridx: 0, widx: 0, cap: 256)
&#x2F;&#x2F;成功进行了解码buf填充了289
PooledUnsafeDirectByteBuf(ridx: 0, widx: 289, cap: 512)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="练习四-简易的IM通讯系统"><a href="#练习四-简易的IM通讯系统" class="headerlink" title="练习四 简易的IM通讯系统"></a>练习四 简易的IM通讯系统</h3><h4 id="任务说明"><a href="#任务说明" class="headerlink" title="任务说明"></a>任务说明</h4><p>实现一个简单的IM通讯系统，包括用户的登录，用户间的消息收发，用户群组间的消息收发，以及群组相关的系列操作，例如创建群聊，加入群聊，退出群聊等</p>
<h4 id="基本架构图"><a href="#基本架构图" class="headerlink" title="基本架构图"></a>基本架构图</h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ad415e153b84c808f3efd7d11418887~tplv-k3u1fbpfcp-watermark.image" alt="基本架构.png"></p>
<h4 id="包结构"><a href="#包结构" class="headerlink" title="包结构"></a>包结构</h4><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e63b2be93a448ca838577fc5d6e674d~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ul>
<li><strong>client:</strong> 与客户端相关的文件</li>
<li><strong>command:</strong> 客户端的所有基本操作指令</li>
<li><strong>message:</strong> 所有类型的请求信息和返回信息</li>
<li><strong>protocol:</strong> 自定义编解码器</li>
<li><strong>server:</strong> 与服务端相关的文件</li>
<li><strong>handler:</strong> 服务端处理入栈请求的处理器</li>
<li><strong>session:</strong> 缓存用户与channel的关系，用户与群组之间的关系</li>
</ul>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p><a target="_blank" rel="noopener" href="https://github.com/bakazhou/JUC/tree/master/NettyDemo/src/main/java/com/cn/tw/graduate/bakazhou/Practice3">git repository</a> practice3模块为具体实现代码</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/09/24/Netty%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" data-id="cl8e65r9d0001ksu55qjmdabx" data-title="Netty网络编程" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-NIO网络通信" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/09/24/NIO%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/" class="article-date">
  <time class="dt-published" datetime="2022-09-23T22:47:49.000Z" itemprop="datePublished">2022-09-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/09/24/NIO%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/">NIO网络通信</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Docs"><a href="#Docs" class="headerlink" title="Docs"></a>Docs</h1><ul>
<li>Oracle官方文档:<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/nio/package-summary.html">https://docs.oracle.com/javase/8/docs/api/java/nio/package-summary.html</a></li>
<li>Practice Repository:<a target="_blank" rel="noopener" href="https://github.com/bakazhou/JUC">https://github.com/bakazhou/JUC</a></li>
</ul>
<h1 id="NIO-非阻塞IO-基础"><a href="#NIO-非阻塞IO-基础" class="headerlink" title="NIO(非阻塞IO)基础"></a>NIO(非阻塞IO)基础</h1><h2 id="1-三大组件"><a href="#1-三大组件" class="headerlink" title="1.三大组件"></a>1.三大组件</h2><h3 id="1-1-Channel-amp-Buffer"><a href="#1-1-Channel-amp-Buffer" class="headerlink" title="1.1 Channel &amp; Buffer"></a>1.1 Channel &amp; Buffer</h3><p>channel与buffer是<code>双向通道</code>，可以从channel将数据读入buffer，也可以将buffer数据写入channel<br>常见的channel:</p>
<ul>
<li>File Channel</li>
<li>Datagram Channel</li>
<li>Socket Channel</li>
<li>Server Socket Channel</li>
</ul>
<p>常用的buffer:</p>
<ul>
<li>ByteBuffer(以下三种均属于ByteBuffer)</li>
<li>MapperByteBuffer</li>
<li>DirectByteBuffer</li>
<li>HeapByteBuffer</li>
</ul>
<h3 id="1-2-Selector"><a href="#1-2-Selector" class="headerlink" title="1.2 Selector"></a>1.2 Selector</h3><h4 id="传统通信设计"><a href="#传统通信设计" class="headerlink" title="传统通信设计"></a>传统通信设计</h4><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c2fd018da4f4b11a3e497562afa00d9~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c620117b0c24dd4a97a7df9ff4a1db1~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h4 id="Selector设计"><a href="#Selector设计" class="headerlink" title="Selector设计"></a>Selector设计</h4><p>selector的作用是配合一个线程管理多个channel，获取channel上发生的事件，channel工作在非阻塞模式下，当channel发生了读写就绪事件，selector会将事件交给thread进行处理</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/935fa244f6e748759a060eee21bb5ba1~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h2 id="2-ByteBuffer"><a href="#2-ByteBuffer" class="headerlink" title="2.ByteBuffer"></a>2.ByteBuffer</h2><h3 id="2-1-ByteBuffer基本使用"><a href="#2-1-ByteBuffer基本使用" class="headerlink" title="2.1 ByteBuffer基本使用"></a>2.1 ByteBuffer基本使用</h3><p>有一普通文本文件data.txt，内容为如下，读取其中数据并组成字符串</p>
<pre class="line-numbers language-none"><code class="language-none">1234567890abcd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">@Test
void shouldReturnStringWhenReadData() &#123;
    &#x2F;&#x2F;File Channel
    &#x2F;&#x2F;通过输入输出流
    try(FileChannel channel &#x3D; new FileInputStream(&quot;src&#x2F;data.txt&quot;).getChannel()) &#123;
        &#x2F;&#x2F;准备缓冲区
        ByteBuffer buffer &#x3D; ByteBuffer.allocate(1);

        StringBuilder stringBuilder &#x3D; new StringBuilder();


        &#x2F;&#x2F;从Channel读取，向Buffer写入
        while (channel.read(buffer) !&#x3D; -1)&#123;
            &#x2F;&#x2F;切换到buffer的读模式
            buffer.flip();
            while (buffer.hasRemaining())&#123;
                byte b &#x3D; buffer.get();
                stringBuilder.append((char) b);
            &#125;

            &#x2F;&#x2F;切换到写模式
            buffer.clear();
        &#125;

        Assertions.assertEquals(&quot;1234567890abcd&quot;,stringBuilder.toString());

    &#125; catch (IOException e) &#123;
        throw new RuntimeException(e);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2-2-Buffer结构"><a href="#2-2-Buffer结构" class="headerlink" title="2.2 Buffer结构"></a>2.2 Buffer结构</h3><p>字节缓冲区的父类Buffer中有几个核心属性，如下</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; Invariants: mark &lt;&#x3D; position &lt;&#x3D; limit &lt;&#x3D; capacity
private int mark &#x3D; -1;
private int position &#x3D; 0;
private int limit;
private int capacity;Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><strong>capacity</strong>：缓冲区的容量。通过构造函数赋予，一旦设置，无法更改</li>
<li><strong>limit</strong>：缓冲区的界限。位于limit 后的数据不可读写。缓冲区的限制不能为负，并且<strong>不能大于其容量</strong></li>
<li><strong>position</strong>：<strong>下一个</strong>读写位置的索引（类似PC）。缓冲区的位置不能为负，并且<strong>不能大于limit</strong></li>
<li><strong>mark</strong>：记录当前position的值。<strong>position被改变后，可以通过调用reset() 方法恢复到mark的位置。</strong></li>
</ul>
<p>以上四个属性必须满足以下要求<br><strong>mark &lt;&#x3D; position &lt;&#x3D; limit &lt;&#x3D; capacity</strong></p>
<h3 id="2-3-核心方法"><a href="#2-3-核心方法" class="headerlink" title="2.3 核心方法"></a>2.3 核心方法</h3><h4 id="put-方法"><a href="#put-方法" class="headerlink" title="put()方法"></a>put()方法<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#put-%E6%96%B9%E6%B3%95"></a></h4><ul>
<li>put()方法可以将一个数据放入到缓冲区中。</li>
<li>进行该操作后，postition的值会+1，指向下一个可以放入的位置。capacity &#x3D; limit ，为缓冲区容量的值。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26a1a6ee0e304eeaa3886e0309cc7f53~tplv-k3u1fbpfcp-zoom-1.image"></a><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145709.png"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d44da2501bb2445ea3c6ea69cf4dca59~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></a></p>
<h4 id="flip-方法"><a href="#flip-方法" class="headerlink" title="flip()方法"></a><a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#flip-%E6%96%B9%E6%B3%95" title="flip()方法"></a>flip()方法<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#flip-%E6%96%B9%E6%B3%95"></a></h4><ul>
<li><p>flip()方法会<strong>切换对缓冲区的操作模式</strong>，由写-&gt;读 &#x2F; 读-&gt;写</p>
</li>
<li><p>进行该操作后</p>
<ul>
<li>如果是写模式-&gt;读模式，position &#x3D; 0 ， limit 指向最后一个元素的下一个位置，capacity不变</li>
<li>如果是读-&gt;写，则恢复为put()方法中的值</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8049578775f419e9127e6d4e0173109~tplv-k3u1fbpfcp-zoom-1.image"></a><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145753.png"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e027706f70e4c2aa3ee1419f1411f01~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></a></p>
<h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a><a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#get-%E6%96%B9%E6%B3%95" title="get()方法"></a>get()方法<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#get-%E6%96%B9%E6%B3%95"></a></h4><ul>
<li>get()方法会读取缓冲区中的一个值</li>
<li>进行该操作后，position会+1，如果超过了limit则会抛出异常</li>
<li><strong>注意：get(i)方法不会改变position的值</strong></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f4efa4e4865442ab9bd39c152742705~tplv-k3u1fbpfcp-zoom-1.image"></a><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145822.png"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ff0f0e912474961bfc179987b546568~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></a></p>
<h4 id="rewind-方法"><a href="#rewind-方法" class="headerlink" title="rewind()方法"></a><a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#rewind-%E6%96%B9%E6%B3%95" title="rewind()方法"></a>rewind()方法<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#rewind-%E6%96%B9%E6%B3%95"></a></h4><ul>
<li>该方法<strong>只能在读模式下使用</strong></li>
<li>rewind()方法后，会恢复position、limit和capacity的值，变为进行get()前的值</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72072c84f6c2400cbea81eeddec126d3~tplv-k3u1fbpfcp-zoom-1.image"></a><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145852.png"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e99870102d89422f830d84560bc4ad81~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></a></p>
<h4 id="clean-方法"><a href="#clean-方法" class="headerlink" title="clean()方法"></a><a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#clean-%E6%96%B9%E6%B3%95" title="clean()方法"></a>clean()方法<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#clean-%E6%96%B9%E6%B3%95"></a></h4><ul>
<li>clean()方法会将缓冲区中的各个属性恢复为最初的状态，position &#x3D; 0, capacity &#x3D; limit</li>
<li><strong>此时缓冲区的数据依然存在</strong>，处于“被遗忘”状态，下次进行写操作时会覆盖这些数据</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b680896cf3744f8b52f041e5522039a~tplv-k3u1fbpfcp-zoom-1.image"></a><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145905.png"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e999bcbd7f24a329e05798e979927bc~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></a></p>
<h4 id="mark-和reset-方法"><a href="#mark-和reset-方法" class="headerlink" title="mark()和reset()方法"></a><a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#mark-%E5%92%8Creset-%E6%96%B9%E6%B3%95" title="mark()和reset()方法"></a>mark()和reset()方法<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#mark-%E5%92%8Creset-%E6%96%B9%E6%B3%95"></a></h4><ul>
<li>mark()方法会将postion的值保存到mark属性中</li>
<li>reset()方法会将position的值改为mark中保存的值</li>
</ul>
<h4 id="compact-方法"><a href="#compact-方法" class="headerlink" title="compact()方法"></a><a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#compact-%E6%96%B9%E6%B3%95" title="compact()方法"></a>compact()方法<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#compact-%E6%96%B9%E6%B3%95"></a></h4><p><strong>此方法为ByteBuffer的方法，而不是Buffer的方法</strong></p>
<ul>
<li>compact会把未读完的数据向前压缩，然后切换到写模式</li>
<li>数据前移后，原位置的值并未清零，写时会<strong>覆盖</strong>之前的值</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210412155726.png"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b02b7fd679764720aff715da78881ac8~tplv-k3u1fbpfcp-zoom-1.image"></a></p>
<h4 id="clear-VS-compact"><a href="#clear-VS-compact" class="headerlink" title="clear() VS compact()"></a><a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#clear-VS-compact" title="clear() VS compact()"></a>clear() VS compact()<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#clear-VS-compact"></a></h4><p>clear只是对position、limit、mark进行重置，而compact在对position进行设置，以及limit、mark进行重置的同时，还涉及到数据在内存中拷贝（会调用arraycopy）。<strong>所以compact比clear更耗性能。</strong> 但compact能保存你未读取的数据，将新数据追加到为读取的数据之后；而clear则不行，若你调用了clear，则未读取的数据就无法再读取到了</p>
<h4 id="开辟buffer空间的两种方式-allocate-amp-allocateDirect"><a href="#开辟buffer空间的两种方式-allocate-amp-allocateDirect" class="headerlink" title="开辟buffer空间的两种方式(allocate &amp; allocateDirect)"></a><strong>开辟buffer空间的两种方式(allocate &amp; allocateDirect)</strong></h4><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;allocate方法开辟的是堆内存空间，读写效率低，同时收到垃圾回收的影响
ByteBuffer allocate &#x3D; ByteBuffer.allocate(16);
&#x2F;&#x2F;allocateDirect方法开辟的是直接内存，读写效率高，分配效率低，可能会造成内存泄漏
ByteBuffer byteBuffer &#x3D; ByteBuffer.allocateDirect(16);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2-4-核心方法测试"><a href="#2-4-核心方法测试" class="headerlink" title="2.4 核心方法测试"></a>2.4 核心方法测试</h3><h4 id="工具类-ByteBufferUtil"><a href="#工具类-ByteBufferUtil" class="headerlink" title="工具类 ByteBufferUtil"></a>工具类 ByteBufferUtil</h4><pre class="line-numbers language-none"><code class="language-none">public class ByteBufferUtil &#123;
    private static final char[] BYTE2CHAR &#x3D; new char[256];
    private static final char[] HEXDUMP_TABLE &#x3D; new char[256 * 4];
    private static final String[] HEXPADDING &#x3D; new String[16];
    private static final String[] HEXDUMP_ROWPREFIXES &#x3D; new String[65536 &gt;&gt;&gt; 4];
    private static final String[] BYTE2HEX &#x3D; new String[256];
    private static final String[] BYTEPADDING &#x3D; new String[16];

    static &#123;
        final char[] DIGITS &#x3D; &quot;0123456789abcdef&quot;.toCharArray();
        for (int i &#x3D; 0; i &lt; 256; i++) &#123;
            HEXDUMP_TABLE[i &lt;&lt; 1] &#x3D; DIGITS[i &gt;&gt;&gt; 4 &amp; 0x0F];
            HEXDUMP_TABLE[(i &lt;&lt; 1) + 1] &#x3D; DIGITS[i &amp; 0x0F];
        &#125;

        int i;

        &#x2F;&#x2F; Generate the lookup table for hex dump paddings
        for (i &#x3D; 0; i &lt; HEXPADDING.length; i++) &#123;
            int padding &#x3D; HEXPADDING.length - i;
            StringBuilder buf &#x3D; new StringBuilder(padding * 3);
            for (int j &#x3D; 0; j &lt; padding; j++) &#123;
                buf.append(&quot;   &quot;);
            &#125;
            HEXPADDING[i] &#x3D; buf.toString();
        &#125;

        &#x2F;&#x2F; Generate the lookup table for the start-offset header in each row (up to 64KiB).
        for (i &#x3D; 0; i &lt; HEXDUMP_ROWPREFIXES.length; i++) &#123;
            StringBuilder buf &#x3D; new StringBuilder(12);
            buf.append(StringUtil.NEWLINE);
            buf.append(Long.toHexString(i &lt;&lt; 4 &amp; 0xFFFFFFFFL | 0x100000000L));
            buf.setCharAt(buf.length() - 9, &#39;|&#39;);
            buf.append(&#39;|&#39;);
            HEXDUMP_ROWPREFIXES[i] &#x3D; buf.toString();
        &#125;

        &#x2F;&#x2F; Generate the lookup table for byte-to-hex-dump conversion
        for (i &#x3D; 0; i &lt; BYTE2HEX.length; i++) &#123;
            BYTE2HEX[i] &#x3D; &#39; &#39; + StringUtil.byteToHexStringPadded(i);
        &#125;

        &#x2F;&#x2F; Generate the lookup table for byte dump paddings
        for (i &#x3D; 0; i &lt; BYTEPADDING.length; i++) &#123;
            int padding &#x3D; BYTEPADDING.length - i;
            StringBuilder buf &#x3D; new StringBuilder(padding);
            for (int j &#x3D; 0; j &lt; padding; j++) &#123;
                buf.append(&#39; &#39;);
            &#125;
            BYTEPADDING[i] &#x3D; buf.toString();
        &#125;

        &#x2F;&#x2F; Generate the lookup table for byte-to-char conversion
        for (i &#x3D; 0; i &lt; BYTE2CHAR.length; i++) &#123;
            if (i &lt;&#x3D; 0x1f || i &gt;&#x3D; 0x7f) &#123;
                BYTE2CHAR[i] &#x3D; &#39;.&#39;;
            &#125; else &#123;
                BYTE2CHAR[i] &#x3D; (char) i;
            &#125;
        &#125;
    &#125;

    &#x2F;**
     * 打印所有内容
     * @param buffer
     *&#x2F;
    public static void debugAll(ByteBuffer buffer) &#123;
        int oldlimit &#x3D; buffer.limit();
        buffer.limit(buffer.capacity());
        StringBuilder origin &#x3D; new StringBuilder(256);
        appendPrettyHexDump(origin, buffer, 0, buffer.capacity());
        System.out.println(&quot;+--------+-------------------- all ------------------------+----------------+&quot;);
        System.out.printf(&quot;position: [%d], limit: [%d]\n&quot;, buffer.position(), oldlimit);
        System.out.println(origin);
        buffer.limit(oldlimit);
    &#125;

    &#x2F;**
     * 打印可读取内容
     * @param buffer
     *&#x2F;
    public static void debugRead(ByteBuffer buffer) &#123;
        StringBuilder builder &#x3D; new StringBuilder(256);
        appendPrettyHexDump(builder, buffer, buffer.position(), buffer.limit() - buffer.position());
        System.out.println(&quot;+--------+-------------------- read -----------------------+----------------+&quot;);
        System.out.printf(&quot;position: [%d], limit: [%d]\n&quot;, buffer.position(), buffer.limit());
        System.out.println(builder);
    &#125;

    private static void appendPrettyHexDump(StringBuilder dump, ByteBuffer buf, int offset, int length) &#123;
        if (MathUtil.isOutOfBounds(offset, length, buf.capacity())) &#123;
            throw new IndexOutOfBoundsException(
                    &quot;expected: &quot; + &quot;0 &lt;&#x3D; offset(&quot; + offset + &quot;) &lt;&#x3D; offset + length(&quot; + length
                            + &quot;) &lt;&#x3D; &quot; + &quot;buf.capacity(&quot; + buf.capacity() + &#39;)&#39;);
        &#125;
        if (length &#x3D;&#x3D; 0) &#123;
            return;
        &#125;
        dump.append(
                &quot;         +-------------------------------------------------+&quot; +
                        StringUtil.NEWLINE + &quot;         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |&quot; +
                        StringUtil.NEWLINE + &quot;+--------+-------------------------------------------------+----------------+&quot;);

        final int startIndex &#x3D; offset;
        final int fullRows &#x3D; length &gt;&gt;&gt; 4;
        final int remainder &#x3D; length &amp; 0xF;

        &#x2F;&#x2F; Dump the rows which have 16 bytes.
        for (int row &#x3D; 0; row &lt; fullRows; row++) &#123;
            int rowStartIndex &#x3D; (row &lt;&lt; 4) + startIndex;

            &#x2F;&#x2F; Per-row prefix.
            appendHexDumpRowPrefix(dump, row, rowStartIndex);

            &#x2F;&#x2F; Hex dump
            int rowEndIndex &#x3D; rowStartIndex + 16;
            for (int j &#x3D; rowStartIndex; j &lt; rowEndIndex; j++) &#123;
                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);
            &#125;
            dump.append(&quot; |&quot;);

            &#x2F;&#x2F; ASCII dump
            for (int j &#x3D; rowStartIndex; j &lt; rowEndIndex; j++) &#123;
                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);
            &#125;
            dump.append(&#39;|&#39;);
        &#125;

        &#x2F;&#x2F; Dump the last row which has less than 16 bytes.
        if (remainder !&#x3D; 0) &#123;
            int rowStartIndex &#x3D; (fullRows &lt;&lt; 4) + startIndex;
            appendHexDumpRowPrefix(dump, fullRows, rowStartIndex);

            &#x2F;&#x2F; Hex dump
            int rowEndIndex &#x3D; rowStartIndex + remainder;
            for (int j &#x3D; rowStartIndex; j &lt; rowEndIndex; j++) &#123;
                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);
            &#125;
            dump.append(HEXPADDING[remainder]);
            dump.append(&quot; |&quot;);

            &#x2F;&#x2F; Ascii dump
            for (int j &#x3D; rowStartIndex; j &lt; rowEndIndex; j++) &#123;
                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);
            &#125;
            dump.append(BYTEPADDING[remainder]);
            dump.append(&#39;|&#39;);
        &#125;

        dump.append(StringUtil.NEWLINE +
                &quot;+--------+-------------------------------------------------+----------------+&quot;);
    &#125;

    private static void appendHexDumpRowPrefix(StringBuilder dump, int row, int rowStartIndex) &#123;
        if (row &lt; HEXDUMP_ROWPREFIXES.length) &#123;
            dump.append(HEXDUMP_ROWPREFIXES[row]);
        &#125; else &#123;
            dump.append(StringUtil.NEWLINE);
            dump.append(Long.toHexString(rowStartIndex &amp; 0xFFFFFFFFL | 0x100000000L));
            dump.setCharAt(dump.length() - 9, &#39;|&#39;);
            dump.append(&#39;|&#39;);
        &#125;
    &#125;

    public static short getUnsignedByte(ByteBuffer buffer, int index) &#123;
        return (short) (buffer.get(index) &amp; 0xFF);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="TestBufferReadWrite"><a href="#TestBufferReadWrite" class="headerlink" title="TestBufferReadWrite"></a>TestBufferReadWrite</h4><p>用于观察数据写入和读取后的缓冲区状态</p>
<pre class="line-numbers language-none"><code class="language-none">public class TestBufferReadWrite &#123;
    @Test
    void test() &#123;
        ByteBuffer buffer &#x3D; ByteBuffer.allocate(10);
        &#x2F;&#x2F; 向buffer中写入1个字节的数据
        buffer.put((byte)97);
        &#x2F;&#x2F; 使用工具类，查看buffer状态
        System.out.println(&quot;Put one element&quot;);
        ByteBufferUtil.debugAll(buffer);

        System.out.println();
        &#x2F;&#x2F; 向buffer中写入4个字节的数据
        buffer.put(new byte[]&#123;98, 99, 100, 101&#125;);
        System.out.println(&quot;Put four element&quot;);
        ByteBufferUtil.debugAll(buffer);
        System.out.println();

        &#x2F;&#x2F; 获取数据
        buffer.flip();
        System.out.println(&quot;before get&quot;);
        ByteBufferUtil.debugAll(buffer);
        System.out.println();

        System.out.println(buffer.get());
        System.out.println(buffer.get());
        System.out.println(&quot;after get twice&quot;);
        ByteBufferUtil.debugAll(buffer);
        System.out.println();
        &#x2F;&#x2F; 使用compact切换模式
        buffer.compact();
        System.out.println(&quot;after compact&quot;);
        ByteBufferUtil.debugAll(buffer);
        System.out.println();
        &#x2F;&#x2F; 再次写入
        buffer.put((byte)102);
        buffer.put((byte)103);
        System.out.println(&quot;after put double element again&quot;);
        ByteBufferUtil.debugAll(buffer);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="字符串与ByteBuffer的相互转换"><a href="#字符串与ByteBuffer的相互转换" class="headerlink" title="字符串与ByteBuffer的相互转换"></a><strong>字符串与ByteBuffer的相互转换</strong><a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8EByteBuffer%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2"></a></h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a><a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#%E6%96%B9%E6%B3%95%E4%B8%80" title="方法一"></a>方法一<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#%E6%96%B9%E6%B3%95%E4%B8%80"></a></h4><p><strong>编码</strong>：字符串调用getByte方法获得byte数组，将byte数组放入ByteBuffer中</p>
<p><strong>解码</strong>：<strong>先调用ByteBuffer的flip方法，然后通过StandardCharsets的decoder方法解码</strong></p>
<pre class="line-numbers language-none"><code class="language-none">public class TestTranslateString &#123;
    public static void main(String[] args) &#123;
        &#x2F;&#x2F; 准备两个字符串
        String str1 &#x3D; &quot;hello&quot;;
        String str2 &#x3D; &quot;&quot;;


        ByteBuffer buffer1 &#x3D; ByteBuffer.allocate(16);
        &#x2F;&#x2F; 通过字符串的getByte方法获得字节数组，放入缓冲区中
        buffer1.put(str1.getBytes());
        ByteBufferUtil.debugAll(buffer1);

        &#x2F;&#x2F; 将缓冲区中的数据转化为字符串
        &#x2F;&#x2F; 切换模式
        buffer1.flip();
        
        &#x2F;&#x2F; 通过StandardCharsets解码，获得CharBuffer，再通过toString获得字符串
        str2 &#x3D; StandardCharsets.UTF_8.decode(buffer1).toString();
        System.out.println(str2);
        ByteBufferUtil.debugAll(buffer1);
    &#125;
&#125;Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果</p>
<pre class="line-numbers language-none"><code class="language-none">+--------+-------------------- all ------------------------+----------------+
position: [5], limit: [16]
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 68 65 6c 6c 6f 00 00 00 00 00 00 00 00 00 00 00 |hello...........|
+--------+-------------------------------------------------+----------------+
hello
+--------+-------------------- all ------------------------+----------------+
position: [5], limit: [5]
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 68 65 6c 6c 6f 00 00 00 00 00 00 00 00 00 00 00 |hello...........|
+--------+-------------------------------------------------+----------------+Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a><a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#%E6%96%B9%E6%B3%95%E4%BA%8C" title="方法二"></a>方法二<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#%E6%96%B9%E6%B3%95%E4%BA%8C"></a></h4><p><strong>编码</strong>：通过StandardCharsets的encode方法获得ByteBuffer，此时获得的ByteBuffer为读模式，无需通过flip切换模式</p>
<p><strong>解码</strong>：通过StandardCharsets的decoder方法解码</p>
<pre class="line-numbers language-none"><code class="language-none">public class TestTranslateString &#123;
    public static void main(String[] args) &#123;
        &#x2F;&#x2F; 准备两个字符串
        String str1 &#x3D; &quot;hello&quot;;
        String str2 &#x3D; &quot;&quot;;

        &#x2F;&#x2F; 通过StandardCharsets的encode方法获得ByteBuffer
        &#x2F;&#x2F; 此时获得的ByteBuffer为读模式，无需通过flip切换模式
        ByteBuffer buffer1 &#x3D; StandardCharsets.UTF_8.encode(str1);
        ByteBufferUtil.debugAll(buffer1);

        &#x2F;&#x2F; 将缓冲区中的数据转化为字符串
        &#x2F;&#x2F; 通过StandardCharsets解码，获得CharBuffer，再通过toString获得字符串
        str2 &#x3D; StandardCharsets.UTF_8.decode(buffer1).toString();
        System.out.println(str2);
        ByteBufferUtil.debugAll(buffer1);
    &#125;
&#125;Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果</p>
<pre class="line-numbers language-none"><code class="language-none">+--------+-------------------- all ------------------------+----------------+
position: [0], limit: [5]
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 68 65 6c 6c 6f                                  |hello           |
+--------+-------------------------------------------------+----------------+
hello
+--------+-------------------- all ------------------------+----------------+
position: [5], limit: [5]
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 68 65 6c 6c 6f                                  |hello           |
+--------+-------------------------------------------------+----------------+Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a><a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#%E6%96%B9%E6%B3%95%E4%B8%89" title="方法三"></a><strong>方法三</strong><a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#%E6%96%B9%E6%B3%95%E4%B8%89"></a></h4><p><strong>编码</strong>：字符串调用getByte()方法获得字节数组，将字节数组传给<strong>ByteBuffer的wrap()方法</strong>，通过该方法获得ByteBuffer。<strong>同样无需调用flip方法切换为读模式</strong></p>
<p><strong>解码</strong>：通过StandardCharsets的decoder方法解码</p>
<pre class="line-numbers language-none"><code class="language-none">public class TestTranslateString &#123;
    public static void main(String[] args) &#123;
        &#x2F;&#x2F; 准备两个字符串
        String str1 &#x3D; &quot;hello&quot;;
        String str2 &#x3D; &quot;&quot;;

        &#x2F;&#x2F; 通过StandardCharsets的encode方法获得ByteBuffer
        &#x2F;&#x2F; 此时获得的ByteBuffer为读模式，无需通过flip切换模式
        ByteBuffer buffer1 &#x3D; ByteBuffer.wrap(str1.getBytes());
        ByteBufferUtil.debugAll(buffer1);

        &#x2F;&#x2F; 将缓冲区中的数据转化为字符串
        &#x2F;&#x2F; 通过StandardCharsets解码，获得CharBuffer，再通过toString获得字符串
        str2 &#x3D; StandardCharsets.UTF_8.decode(buffer1).toString();
        System.out.println(str2);
        ByteBufferUtil.debugAll(buffer1);
    &#125;
&#125;Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果</p>
<pre class="line-numbers language-none"><code class="language-none">+--------+-------------------- all ------------------------+----------------+
position: [0], limit: [5]
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 68 65 6c 6c 6f                                  |hello           |
+--------+-------------------------------------------------+----------------+
hello
+--------+-------------------- all ------------------------+----------------+
position: [5], limit: [5]
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 68 65 6c 6c 6f                                  |hello           |
+--------+-------------------------------------------------+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="粘包与半包"><a href="#粘包与半包" class="headerlink" title="粘包与半包"></a>粘包与半包</h3><h4 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#%E7%8E%B0%E8%B1%A1"></a></h4><p>网络上有多条数据发送给服务端，数据之间使用\n进行分隔<br>但由于某种原因这些数据在接收时，被进行了重新组合，例如原始数据有3条为</p>
<ul>
<li>Hello,world\n</li>
<li>I’m Nyima\n</li>
<li>How are you?\n</li>
</ul>
<p>变成了下面的两个 byteBuffer (粘包，半包)</p>
<ul>
<li>Hello,world\nI’m Nyima\nHo</li>
<li>w are you?\n</li>
</ul>
<p><strong>粘包:</strong><br>两条消息被组合在一起即为粘包，一般出现的原因是因为多条消息被一起发送<br><strong>半包:</strong><br>消息被截断为半包，一般出现原因是因为接收方一次能接收的最大信息量有限，因而产生半包的现象</p>
<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"></a></h4><ul>
<li><p>通过get(index)方法遍历ByteBuffer，遇到分隔符时进行处理。<strong>注意</strong>：get(index)不会改变position的值</p>
<ul>
<li>记录该段数据长度，以便于申请对应大小的缓冲区</li>
<li>将缓冲区的数据通过get()方法写入到target中</li>
</ul>
</li>
<li><p>调用<strong>compact方法</strong>切换模式，因为缓冲区中可能还有未读的数据</p>
</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">public class TestVisioPacket &#123;
    @Test
    void testVisioPacket() &#123;
        ByteBuffer buffer &#x3D; ByteBuffer.allocate(32);
        &#x2F;&#x2F; 模拟粘包+半包
        buffer.put(&quot;Hello,world\nI&#39;m Nyima\nHo&quot;.getBytes());
        &#x2F;&#x2F; 调用split函数处理
        split(buffer);
        buffer.put(&quot;w are you?\n&quot;.getBytes());
        split(buffer);
    &#125;

    private void split(ByteBuffer buffer) &#123;
        buffer.flip();
        for (int i &#x3D; 0; i &lt; buffer.limit(); i++) &#123;
            &#x2F;&#x2F;找到换行符的下标
            &#x2F;&#x2F;调用get(index)方法并不会改变position的位置
            if (buffer.get(i) &#x3D;&#x3D; &#39;\n&#39;)&#123;
                StringBuilder builder &#x3D; new StringBuilder();
                &#x2F;&#x2F;当前换行符前的字符长度，即需要取出的缓冲区长度
                int length &#x3D; i + 1 - buffer.position();
                for (int j &#x3D; 0; j &lt; length; j++) &#123;
                    &#x2F;&#x2F;取出buffer中的字符，get方法会使position+1
                    builder.append((char)buffer.get());
                &#125;
                System.out.println(&quot;string:&quot;+builder.toString());
            &#125;
        &#125;
        &#x2F;&#x2F;调用compact，使缓冲区中未读取完的字符不会被清空
        &#x2F;*
        例如Hello,world\nI&#39;m Nyima\nHo
        因为Ho后没有\n所以Ho不会被取出，compact会将Ho向前压缩，再第二次读取时就会组成How are you?\n
         *&#x2F;
        buffer.compact();
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><ul>
<li><p>阻塞模式下，相关方法都会导致线程暂停</p>
<ul>
<li>ServerSocketChannel.accept 会在<strong>没有连接建立时</strong>让线程暂停</li>
<li>SocketChannel.read 会在<strong>通道中没有数据可读时</strong>让线程暂停</li>
<li>阻塞的表现其实就是线程暂停了，暂停期间不会占用 cpu，但线程相当于闲置</li>
</ul>
</li>
<li><p>单线程下，阻塞方法之间相互影响，几乎不能正常工作，需要多线程支持</p>
</li>
<li><p>但多线程下，有新的问题，体现在以下方面</p>
<ul>
<li>32 位 jvm 一个线程 320k，64 位 jvm 一个线程 1024k，如果连接数过多，必然导致 OOM，并且线程太多，反而会因为频繁上下文切换导致性能降低</li>
<li>可以采用线程池技术来减少线程数和线程上下文切换，但治标不治本，如果有很多连接建立，但长时间 inactive，会阻塞线程池中所有线程，因此不适合长连接，只适合短连接</li>
</ul>
</li>
</ul>
<h4 id="ServiceServer"><a href="#ServiceServer" class="headerlink" title="ServiceServer"></a>ServiceServer</h4><pre class="line-numbers language-none"><code class="language-none">public class ServerDemo &#123;
    public static void main(String[] args) throws IOException &#123;
        &#x2F;&#x2F;  使用nio

        ByteBuffer buffer &#x3D; ByteBuffer.allocate(16);
        &#x2F;&#x2F; 创建服务端服务器
        ServerSocketChannel server &#x3D; ServerSocketChannel.open();

        &#x2F;&#x2F; 绑定监听端口
        server.bind(new InetSocketAddress(8080));

        &#x2F;&#x2F; 客户端连接accept
        List&lt;SocketChannel&gt; channels &#x3D; new ArrayList&lt;&gt;();
        while (true)&#123;
            System.out.println(&quot;waiting for connecting&quot;);
            &#x2F;&#x2F;用于客户端通信
            &#x2F;&#x2F;accept是阻塞方法，如果没有新的连接就会一直阻塞在此处
            channels.add(server.accept());

            System.out.println(&quot;client connected&quot;);
            for (SocketChannel channel : channels) &#123;
                System.out.println(&quot;before read&quot;);
                &#x2F;&#x2F; 接受客户端数据
                channel.read(buffer);

                &#x2F;&#x2F; 切换到读模式
                buffer.flip();
                ByteBufferUtil.debugRead(buffer);

                System.out.println(&quot;after read&quot;);
                System.out.println();
                &#x2F;&#x2F;切换到写模式
                buffer.clear();
            &#125;

        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="ClientServer"><a href="#ClientServer" class="headerlink" title="ClientServer"></a>ClientServer</h4><pre class="line-numbers language-none"><code class="language-none">public class ClientDemo &#123;
    public static void main(String[] args) throws IOException &#123;
        &#x2F;&#x2F; 创建客户端服务器
        SocketChannel client &#x3D; SocketChannel.open();

        &#x2F;&#x2F; 进行连接
        client.connect(new InetSocketAddress(&quot;localhost&quot;,8080));

        client.write(Charset.defaultCharset().encode(&quot;Hello! Im client&quot;));

    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h3><ul>
<li>可以通过ServerSocketChannel的configureBlocking(<strong>false</strong>)方法将<strong>获得连接设置为非阻塞的</strong>。此时若没有连接，accept会返回null</li>
<li>可以通过SocketChannel的configureBlocking(<strong>false</strong>)方法将从通道中<strong>读取数据设置为非阻塞的</strong>。若此时通道中没有数据可读，read会返回-1</li>
</ul>
<h4 id="ServiceServer-1"><a href="#ServiceServer-1" class="headerlink" title="ServiceServer"></a>ServiceServer</h4><pre class="line-numbers language-none"><code class="language-none">public class ServerDemo &#123;
    public static void main(String[] args) throws IOException &#123;
        &#x2F;&#x2F; 创建缓冲区
        ByteBuffer buffer &#x3D; ByteBuffer.allocate(16);
        &#x2F;&#x2F; 获得服务器通道
        try(ServerSocketChannel server &#x3D; ServerSocketChannel.open()) &#123;
            &#x2F;&#x2F; 为服务器通道绑定端口
            server.bind(new InetSocketAddress(8080));
            &#x2F;&#x2F; 用户存放连接的集合
            ArrayList&lt;SocketChannel&gt; channels &#x3D; new ArrayList&lt;&gt;();
            &#x2F;&#x2F; 循环接收连接
            while (true) &#123;
                &#x2F;&#x2F; 设置为非阻塞模式，没有连接时返回null，不会阻塞线程
                server.configureBlocking(false);
                SocketChannel socketChannel &#x3D; server.accept();
                System.out.println(&quot;before connecting...&quot;);
                &#x2F;&#x2F; 通道不为空时才将连接放入到集合中
                if (socketChannel !&#x3D; null) &#123;
                    System.out.println(&quot;after connecting...&quot;);
                    channels.add(socketChannel);
                &#125;
                &#x2F;&#x2F; 循环遍历集合中的连接
                for(SocketChannel channel : channels) &#123;
                    &#x2F;&#x2F; 处理通道中的数据
                    &#x2F;&#x2F; 设置为非阻塞模式，若通道中没有数据，会返回0，不会阻塞线程
                    channel.configureBlocking(false);
                    int read &#x3D; channel.read(buffer);
                    if(read &gt; 0) &#123;
                        buffer.flip();
                        ByteBufferUtil.debugRead(buffer);
                        buffer.clear();
                        System.out.println(&quot;after reading&quot;);
                    &#125;
                &#125;
            &#125;
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样写存在一个问题，因为设置为了非阻塞，会一直执行while(true)中的代码，CPU一直处于忙碌状态，会使得性能变低，所以实际情况中不使用这种方法处理请求</p>
<h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><p>单线程可以配合 Selector 完成对多个 Channel 可读写事件的监控，这称之为多路复用</p>
<ul>
<li><p><strong>多路复用仅针对网络 IO</strong>，普通文件 IO <strong>无法</strong>利用多路复用</p>
</li>
<li><p>如果不用 Selector 的非阻塞模式，线程大部分时间都在做无用功，而 Selector 能够保证</p>
<ul>
<li><p>有可连接事件时才去连接</p>
</li>
<li><p>有可读事件才去读取</p>
</li>
<li><p>有可写事件才去写入</p>
<ul>
<li>限于网络传输能力，Channel 未必时时可写，一旦 Channel 可写，会触发 Selector 的可写事件</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Accept事件"><a href="#Accept事件" class="headerlink" title="Accept事件"></a>Accept事件</h4> <pre class="line-numbers language-none"><code class="language-none">public class ServerDemo &#123;
    public static void main(String[] args) &#123;

        ByteBuffer buffer &#x3D; ByteBuffer.allocate(16);
        &#x2F;&#x2F; 获得服务器通道
        try(ServerSocketChannel server &#x3D; ServerSocketChannel.open()) &#123;
            server.bind(new InetSocketAddress(8080));
            &#x2F;&#x2F; 创建选择器
            Selector selector &#x3D; Selector.open();

            &#x2F;&#x2F; 通道必须设置为非阻塞模式
            server.configureBlocking(false);
            &#x2F;&#x2F; 将通道注册到选择器中，并设置感兴趣的事件
            server.register(selector, SelectionKey.OP_ACCEPT);
            while (true) &#123;
                &#x2F;&#x2F; 若没有事件就绪，线程会被阻塞，反之不会被阻塞。从而避免了CPU空转
                &#x2F;&#x2F; 返回值为就绪的事件个数
                int ready &#x3D; selector.select();
                System.out.println(&quot;selector ready counts : &quot; + ready);

                &#x2F;&#x2F; 获取所有事件
                Set&lt;SelectionKey&gt; selectionKeys &#x3D; selector.selectedKeys();

                &#x2F;&#x2F; 使用迭代器遍历事件
                Iterator&lt;SelectionKey&gt; iterator &#x3D; selectionKeys.iterator();
                while (iterator.hasNext()) &#123;
                    SelectionKey key &#x3D; iterator.next();

                    &#x2F;&#x2F; 判断key的类型
                    if(key.isAcceptable()) &#123;
                        &#x2F;&#x2F; 获得key对应的channel
                        ServerSocketChannel channel &#x3D; (ServerSocketChannel) key.channel();
                        System.out.println(&quot;before accepting...&quot;);

                        &#x2F;&#x2F; 获取连接并处理，而且是必须处理，否则需要取消
                        SocketChannel socketChannel &#x3D; channel.accept();
                        System.out.println(&quot;after accepting...&quot;);

                        &#x2F;&#x2F; 处理完毕后移除
                        iterator.remove();
                    &#125;
                &#125;
            &#125;
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>步骤解析</strong></p>
<ul>
<li>获得选择器Selector</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">Selector selector &#x3D; Selector.open();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li><p>将<strong>通道设置为非阻塞模式</strong>，并注册到选择器中，并设置感兴趣的事件</p>
<ul>
<li><p>channel 必须工作在非阻塞模式</p>
</li>
<li><p>FileChannel 没有非阻塞模式，因此不能配合 selector 一起使用</p>
</li>
<li><p>绑定的<strong>事件类型</strong>可以有</p>
<ul>
<li>connect - 客户端连接成功时触发</li>
<li>accept - 服务器端成功接受连接时触发</li>
<li>read - 数据可读入时触发，有因为接收能力弱，数据暂不能读入的情况</li>
<li>write - 数据可写出时触发，有因为发送能力弱，数据暂不能写出的情况</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 通道必须设置为非阻塞模式
server.configureBlocking(false);
&#x2F;&#x2F; 将通道注册到选择器中，并设置感兴趣的事件
server.register(selector, SelectionKey.OP_ACCEPT);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p>通过Selector监听事件，并获得就绪的通道个数，若没有通道就绪，线程会被阻塞</p>
<ul>
<li><p>阻塞直到绑定事件发生</p>
<pre class="line-numbers language-none"><code class="language-none">int count &#x3D; selector.select();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>阻塞直到绑定事件发生，<strong>或是超时</strong>（时间单位为 ms）</p>
<pre class="line-numbers language-none"><code class="language-none">int count &#x3D; selector.select(long timeout);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p><strong>不会阻塞</strong>，也就是不管有没有事件，立刻返回，自己根据返回值检查是否有事件</p>
<pre class="line-numbers language-none"><code class="language-none">int count &#x3D; selector.selectNow();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ul>
</li>
<li><p>获取就绪事件并<strong>得到对应的通道</strong>，然后进行处理</p>
</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 获取所有事件
Set&lt;SelectionKey&gt; selectionKeys &#x3D; selector.selectedKeys();
                
&#x2F;&#x2F; 使用迭代器遍历事件
Iterator&lt;SelectionKey&gt; iterator &#x3D; selectionKeys.iterator();

while (iterator.hasNext()) &#123;
	SelectionKey key &#x3D; iterator.next();
                    
	&#x2F;&#x2F; 判断key的类型，此处为Accept类型
	if(key.isAcceptable()) &#123;
        &#x2F;&#x2F; 获得key对应的channel
        ServerSocketChannel channel &#x3D; (ServerSocketChannel) key.channel();

        &#x2F;&#x2F; 获取连接并处理，而且是必须处理，否则需要取消
        SocketChannel socketChannel &#x3D; channel.accept();

        &#x2F;&#x2F; 处理完毕后移除
        iterator.remove();
	&#125;
&#125;Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>事件发生后能否不处理</strong></p>
<p>事件发生后，<strong>要么处理，要么取消（cancel）</strong> ，不能什么都不做，<strong>否则下次该事件仍会触发</strong>，这是因为 nio 底层使用的是水平触发</p>
<h4 id="Read事件"><a href="#Read事件" class="headerlink" title="Read事件"></a>Read事件</h4><ul>
<li>在Accept事件中，若有客户端与服务器端建立了连接，<strong>需要将其对应的SocketChannel设置为非阻塞，并注册到选择其中</strong></li>
<li>添加Read事件，触发后进行读取操作</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">public class SelectServer &#123;
    public static void main(String[] args) &#123;
        ByteBuffer buffer &#x3D; ByteBuffer.allocate(16);
        &#x2F;&#x2F; 获得服务器通道
        try(ServerSocketChannel server &#x3D; ServerSocketChannel.open()) &#123;
            server.bind(new InetSocketAddress(8080));
            &#x2F;&#x2F; 创建选择器
            Selector selector &#x3D; Selector.open();
            &#x2F;&#x2F; 通道必须设置为非阻塞模式
            server.configureBlocking(false);
            &#x2F;&#x2F; 将通道注册到选择器中，并设置感兴趣的实践
            server.register(selector, SelectionKey.OP_ACCEPT);
            &#x2F;&#x2F; 为serverKey设置感兴趣的事件
            while (true) &#123;
                &#x2F;&#x2F; 若没有事件就绪，线程会被阻塞，反之不会被阻塞。从而避免了CPU空转
                &#x2F;&#x2F; 返回值为就绪的事件个数
                int ready &#x3D; selector.select();
                System.out.println(&quot;selector ready counts : &quot; + ready);
                &#x2F;&#x2F; 获取所有事件
                Set&lt;SelectionKey&gt; selectionKeys &#x3D; selector.selectedKeys();
                &#x2F;&#x2F; 使用迭代器遍历事件
                Iterator&lt;SelectionKey&gt; iterator &#x3D; selectionKeys.iterator();
                while (iterator.hasNext()) &#123;
                    SelectionKey key &#x3D; iterator.next();
                    &#x2F;&#x2F; 判断key的类型
                    if(key.isAcceptable()) &#123;
                        &#x2F;&#x2F; 获得key对应的channel
                        ServerSocketChannel channel &#x3D; (ServerSocketChannel) key.channel();
                        System.out.println(&quot;before accepting...&quot;);
                        &#x2F;&#x2F; 获取连接
                        SocketChannel socketChannel &#x3D; channel.accept();
                        System.out.println(&quot;after accepting...&quot;);
                        &#x2F;&#x2F; 设置为非阻塞模式，同时将连接的通道也注册到选择其中
                        socketChannel.configureBlocking(false);
                        socketChannel.register(selector, SelectionKey.OP_READ);
                        &#x2F;&#x2F; 处理完毕后移除
                        iterator.remove();
                    &#125; else if (key.isReadable()) &#123;
                        SocketChannel channel &#x3D; (SocketChannel) key.channel();
                        System.out.println(&quot;before reading...&quot;);
                        channel.read(buffer);
                        System.out.println(&quot;after reading...&quot;);
                        buffer.flip();
                        ByteBufferUtil.debugRead(buffer);
                        buffer.clear();
                        &#x2F;&#x2F; 处理完毕后移除
                        iterator.remove();
                    &#125;
                &#125;
            &#125;
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>当处理完一个事件后，一定要调用迭代器的remove方法移除对应事件，否则会出现错误</strong>。原因如下</p>
<p>以我们上面的 <strong>Read事件</strong> 的代码为例</p>
<ul>
<li><p>当调用了 server.register(selector, SelectionKey.OP_ACCEPT)后，Selector中维护了一个集合，<strong>用于存放SelectionKey以及其对应的通道</strong></p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; WindowsSelectorImpl 中的 SelectionKeyImpl数组
private SelectionKeyImpl[] channelArray &#x3D; new SelectionKeyImpl[8];Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">public class SelectionKeyImpl extends AbstractSelectionKey &#123;
    &#x2F;&#x2F; Key对应的通道
    final SelChImpl channel;
    ...
&#125;Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210414192429.png"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70ae74562fbb4b318eb52f510b0b801b~tplv-k3u1fbpfcp-zoom-1.image"></a></p>
</li>
<li><p>当<strong>选择器中的通道对应的事件发生后</strong>，selecionKey会被放到另一个集合中，但是<strong>selecionKey不会自动移除</strong>，所以需要我们在处理完一个事件后，通过迭代器手动移除其中的selecionKey。否则会导致已被处理过的事件再次被处理，就会引发错误<a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210414193143.png"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5179898ec9c64325a74e0a72e1681da2~tplv-k3u1fbpfcp-zoom-1.image"></a></p>
</li>
</ul>
<h2 id="NIO-BIO"><a href="#NIO-BIO" class="headerlink" title="NIO BIO"></a>NIO BIO</h2><h2 id="Stream与Channel"><a href="#Stream与Channel" class="headerlink" title="Stream与Channel"></a>Stream与Channel<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#1%E3%80%81Stream%E4%B8%8EChannel"></a></h2><ul>
<li>stream 不会自动缓冲数据，channel 会利用系统提供的发送缓冲区、接收缓冲区（更为底层）</li>
<li>stream 仅支持阻塞 API，channel 同时支持阻塞、非阻塞 API，<strong>网络 channel 可配合 selector 实现多路复用</strong></li>
<li>二者<strong>均为全双工</strong>，即读写可以同时进行<ul>
<li>虽然Stream是单向流动的，但是它也是全双工的</li>
</ul>
</li>
</ul>
<h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#2%E3%80%81IO%E6%A8%A1%E5%9E%8B"></a></h2><ul>
<li><p><strong>同步</strong>：线程自己去获取结果（一个线程）</p>
<ul>
<li>例如：线程调用一个方法后，需要等待方法返回结果</li>
</ul>
</li>
<li><p><strong>异步</strong>：线程自己不去获取结果，而是由其它线程返回结果（至少两个线程）</p>
<ul>
<li>例如：线程A调用一个方法后，继续向下运行，运行结果由线程B返回</li>
</ul>
</li>
</ul>
<p>当调用一次 channel.<strong>read</strong> 或 stream.<strong>read</strong> 后，会由用户态切换至操作系统内核态来完成真正数据读取，而读取又分为两个阶段，分别为：</p>
<ul>
<li><p>等待数据阶段</p>
</li>
<li><p>复制数据阶段</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418151243.png"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c022c78f4174fcaaba370ce0e105648~tplv-k3u1fbpfcp-zoom-1.image"></a></p>
</li>
</ul>
<p>根据UNIX 网络编程 - 卷 I，IO模型主要有以下几种</p>
<h3 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a><a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#%E9%98%BB%E5%A1%9EIO" title="阻塞IO"></a>阻塞IO<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#%E9%98%BB%E5%A1%9EIO"></a></h3><p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418151605.png"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fbcfe71a0a484b39a88cef503b439d46~tplv-k3u1fbpfcp-zoom-1.image"></a></p>
<ul>
<li>用户线程进行read操作时，<strong>需要等待操作系统执行实际的read操作</strong>，此期间用户线程是被阻塞的，无法执行其他操作</li>
</ul>
<h3 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a><a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#%E9%9D%9E%E9%98%BB%E5%A1%9EIO" title="非阻塞IO"></a>非阻塞IO<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#%E9%9D%9E%E9%98%BB%E5%A1%9EIO"></a></h3><p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418152137.png"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c772b7242c54afba56f1568f5505a08~tplv-k3u1fbpfcp-zoom-1.image"></a></p>
<ul>
<li><p>用户线程<strong>在一个循环中一直调用read方法</strong>，若内核空间中还没有数据可读，立即返回</p>
<ul>
<li><strong>只是在等待阶段非阻塞</strong></li>
</ul>
</li>
<li><p>用户线程发现内核空间中有数据后，等待内核空间执行复制数据，待复制结束后返回结果</p>
</li>
</ul>
<h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a><a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-1" title="多路复用"></a>多路复用<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-1"></a></h3><p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418154208.png"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/270cdcfcad3e4c49b9ca894b3b4092fe~tplv-k3u1fbpfcp-zoom-1.image"></a></p>
<p><strong>Java中通过Selector实现多路复用</strong></p>
<ul>
<li>当没有事件是，调用select方法会被阻塞住</li>
<li>一旦有一个或多个事件发生后，就会处理对应的事件，从而实现多路复用</li>
</ul>
<p><strong>多路复用与阻塞IO的区别</strong></p>
<ul>
<li>阻塞IO模式下，<strong>若线程因accept事件被阻塞，发生read事件后，仍需等待accept事件执行完成后</strong>，才能去处理read事件</li>
<li>多路复用模式下，一个事件发生后，若另一个事件处于阻塞状态，不会影响该事件的执行</li>
</ul>
<h3 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a><a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#%E5%BC%82%E6%AD%A5IO" title="异步IO"></a>异步IO<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#%E5%BC%82%E6%AD%A5IO"></a></h3><p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418160106.png"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f783ddb84b94a5591e0786fb8d83b4d~tplv-k3u1fbpfcp-zoom-1.image"></a></p>
<ul>
<li>线程1调用方法后理解返回，<strong>不会被阻塞也不需要立即获取结果</strong></li>
<li>当方法的运行结果出来以后，由线程2将结果返回给线程1</li>
</ul>
<h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a><a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#3%E3%80%81%E9%9B%B6%E6%8B%B7%E8%B4%9D" title="3、零拷贝"></a>零拷贝<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#3%E3%80%81%E9%9B%B6%E6%8B%B7%E8%B4%9D"></a></h2><p><strong>零拷贝指的是数据无需拷贝到 JVM 内存中</strong>，同时具有以下三个优点</p>
<ul>
<li>更少的用户态与内核态的切换</li>
<li>不利用 cpu 计算，减少 cpu 缓存伪共享</li>
<li>零拷贝适合小文件传输</li>
</ul>
<h3 id="传统-IO-问题"><a href="#传统-IO-问题" class="headerlink" title="传统 IO 问题"></a><a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#%E4%BC%A0%E7%BB%9F-IO-%E9%97%AE%E9%A2%98" title="传统 IO 问题"></a>传统 IO 问题<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#%E4%BC%A0%E7%BB%9F-IO-%E9%97%AE%E9%A2%98"></a></h3><p>传统的 IO 将一个文件通过 socket 写出</p>
<pre class="line-numbers language-none"><code class="language-none">File f &#x3D; new File(&quot;helloword&#x2F;data.txt&quot;);
RandomAccessFile file &#x3D; new RandomAccessFile(file, &quot;r&quot;);

byte[] buf &#x3D; new byte[(int)f.length()];
file.read(buf);

Socket socket &#x3D; ...;
socket.getOutputStream().write(buf);Copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>内部工作流如下</strong></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418162306.png"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a9d5b85a8c10475d8fe9cbfb1822c44e~tplv-k3u1fbpfcp-zoom-1.image"></a></p>
<ul>
<li><p>Java 本身并不具备 IO 读写能力，因此 read 方法调用后，要从 Java 程序的<strong>用户态切换至内核态</strong>，去调用操作系统（Kernel）的读能力，将数据读入<strong>内核缓冲区</strong>。这期间用户线程阻塞，操作系统使用 DMA（Direct Memory Access）来实现文件读，其间也不会使用 CPU</p>
<p><code>DMA 也可以理解为硬件单元，用来解放 cpu 完成文件 IO</code></p>
</li>
<li><p>从<strong>内核态</strong>切换回<strong>用户态</strong>，将数据从<strong>内核缓冲区</strong>读入<strong>用户缓冲区</strong>（即 byte[] buf），这期间 <strong>CPU 会参与拷贝</strong>，无法利用 DMA</p>
</li>
<li><p>调用 write 方法，这时将数据从<strong>用户缓冲区</strong>（byte[] buf）写入 <strong>socket 缓冲区，CPU 会参与拷贝</strong></p>
</li>
<li><p>接下来要向网卡写数据，这项能力 Java 又不具备，因此又得从<strong>用户态</strong>切换至<strong>内核态</strong>，调用操作系统的写能力，使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 CPU</p>
</li>
</ul>
<p>可以看到中间环节较多，java 的 IO 实际不是物理设备级别的读写，而是缓存的复制，底层的真正读写是操作系统来完成的</p>
<ul>
<li>用户态与内核态的切换发生了 3 次，这个操作比较重量级</li>
<li>数据拷贝了共 4 次</li>
</ul>
<h3 id="NIO-优化"><a href="#NIO-优化" class="headerlink" title="NIO 优化"></a><a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#NIO-%E4%BC%98%E5%8C%96" title="NIO 优化"></a>NIO 优化<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#NIO-%E4%BC%98%E5%8C%96"></a></h3><p>通过 <strong>DirectByteBuf</strong></p>
<ul>
<li><p>ByteBuffer.allocate(10)</p>
<ul>
<li>底层对应 HeapByteBuffer，使用的还是 Java 内存</li>
</ul>
</li>
<li><p>ByteBuffer.<strong>allocateDirect</strong>(10)</p>
<ul>
<li>底层对应DirectByteBuffer，<strong>使用的是操作系统内存</strong></li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418162410.png"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/57a5e9aeb2bb46b781b4e81b11c431a0~tplv-k3u1fbpfcp-zoom-1.image"></a></p>
<p>大部分步骤与优化前相同，唯有一点：<strong>Java 可以使用 DirectByteBuffer 将堆外内存映射到 JVM 内存中来直接访问使用</strong></p>
<ul>
<li><p>这块内存不受 JVM 垃圾回收的影响，因此内存地址固定，有助于 IO 读写</p>
</li>
<li><p>Java 中的 DirectByteBuf 对象仅维护了此内存的虚引用，内存回收分成两步</p>
<ul>
<li><p>DirectByteBuffer 对象被垃圾回收，将虚引用加入引用队列</p>
<ul>
<li>当引用的对象ByteBuffer被垃圾回收以后，虚引用对象Cleaner就会被放入引用队列中，然后调用Cleaner的clean方法来释放直接内存</li>
<li>DirectByteBuffer 的释放底层调用的是 Unsafe 的 freeMemory 方法</li>
</ul>
</li>
<li><p>通过专门线程访问引用队列，根据虚引用释放堆外内存</p>
</li>
</ul>
</li>
<li><p><strong>减少了一次数据拷贝，用户态与内核态的切换次数没有减少</strong></p>
</li>
</ul>
<h3 id="进一步优化1"><a href="#进一步优化1" class="headerlink" title="进一步优化1"></a><a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BC%98%E5%8C%961" title="进一步优化1"></a>进一步优化1<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BC%98%E5%8C%961"></a></h3><p><strong>以下两种方式都是零拷贝</strong>，即无需将数据拷贝到用户缓冲区中（JVM内存中）</p>
<p>底层采用了 <strong>linux 2.1</strong> 后提供的 <strong>sendFile</strong> 方法，Java 中对应着两个 channel 调用 <strong>transferTo&#x2F;transferFrom</strong> 方法拷贝数据</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418162750.png"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dbf572cef10749c9b36859d3b7c5eeee~tplv-k3u1fbpfcp-zoom-1.image"></a></p>
<ul>
<li>Java 调用 transferTo 方法后，要从 Java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA将数据读入<strong>内核缓冲区</strong>，不会使用 CPU</li>
<li>数据从<strong>内核缓冲区</strong>传输到 <strong>socket 缓冲区</strong>，CPU 会参与拷贝</li>
<li>最后使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 CPU</li>
</ul>
<p>这种方法下</p>
<ul>
<li>只发生了1次用户态与内核态的切换</li>
<li>数据拷贝了 3 次</li>
</ul>
<h3 id="进一步优化2"><a href="#进一步优化2" class="headerlink" title="进一步优化2"></a><a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BC%98%E5%8C%962" title="进一步优化2"></a>进一步优化2<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BC%98%E5%8C%962"></a></h3><p><strong>linux 2.4</strong> 对上述方法再次进行了优化</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418163033.png"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2ada3cf2710433dbebf60630666fa8e~tplv-k3u1fbpfcp-zoom-1.image"></a></p>
<ul>
<li>Java 调用 transferTo 方法后，要从 Java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA将数据读入<strong>内核缓冲区</strong>，不会使用 CPU</li>
<li>只会将一些 offset 和 length 信息拷入 <strong>socket 缓冲区</strong>，几乎无消耗</li>
<li>使用 DMA 将 <strong>内核缓冲区</strong>的数据写入网卡，不会使用 CPU</li>
</ul>
<p><strong>整个过程仅只发生了1次用户态与内核态的切换，数据拷贝了 2 次</strong></p>
<h2 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a><a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#4%E3%80%81AIO" title="4、AIO"></a>AIO<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2021/04/18/Netty%E5%AD%A6%E4%B9%A0%E4%B9%8BNIO%E5%9F%BA%E7%A1%80/#4%E3%80%81AIO"></a></h2><p>AIO 用来解决数据复制阶段的阻塞问题</p>
<ul>
<li>同步意味着，在进行读写操作时，线程需要等待结果，还是相当于闲置</li>
<li>异步意味着，在进行读写操作时，线程不必等待结果，而是将来由操作系统来通过回调方式由另外的线程来获得结果</li>
</ul>
<blockquote>
<p>异步模型需要底层操作系统（Kernel）提供支持</p>
<ul>
<li>Windows 系统通过 IOCP <strong>实现了真正的异步 IO</strong></li>
<li>Linux 系统异步 IO 在 2.6 版本引入，但其<strong>底层实现还是用多路复用模拟了异步 IO，性能没有优势</strong></li>
</ul>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/09/24/NIO%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/" data-id="cl8e65r9b0000ksu56ztq7in2" data-title="NIO网络通信" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/09/24/Netty%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">Netty网络编程</a>
          </li>
        
          <li>
            <a href="/2022/09/24/NIO%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/">NIO网络通信</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 Bakazhou<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>